<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【干了这杯源码】集合框架 List之Stack（五）]]></title>
    <url>%2F2018%2F11%2F24%2F%E3%80%90%E5%B9%B2%E4%BA%86%E8%BF%99%E6%9D%AF%E6%BA%90%E7%A0%81%E3%80%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-List%E4%B9%8BStack%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Stack一 概述​ Stack英文意思为一大堆，Java JDK中的Stack类用于模拟数据结构中的栈。​ 什么是栈结构，用最简单的比喻，栈结构就如同桌子上整齐堆叠的一些书本，当你存放的时候，必须一本一本的往上放(入栈)，当你取书的时候必须从最上面一本一本的往下拿(出栈)。​ 所以，栈结构的特点是先进者后出，后进者先出，就是所谓的FILO( First In Last Out)。​ Stack 继承于Vector类，所以Stack是一个线程安全的基于数组实现的栈结构。​ 提示：JDK中的Deque接口提供了一个更加优秀和实用的LIFO栈结构，用来替代Stack类: 1`Deque stack = new ArrayDeque();` Stack继承图 二 Stack的属性​ 由于Stack继承Vector类，所以Stack的属性就是Vector的属性，无额外属性。 1 elementData12//该属性为Object类型的空数组,是Stack的底层存储数组protected Object[] elementData; 2 elementCount12//Stack的实际元素个数(等同于其他集合的size)protected int elementCount; 3 capacityIncrement123//capacityIncrement为Stack每次自动增长的大小，//若capacityIncrement小于等于0，则按默认自动扩充为原来的1倍protected int capacityIncrement; 4 modCount1234567//modCount属性为list被结构性修改(structurally modified)的总次数，//结构性修改为任意对size进行修改的操作，如add()、remove()等。//modCount属性继承于父抽象类AbstractList。//modCount属性的主要用于确保iterator遍历的准确性，防止多个线程对该list进行操作，//如果在iterator遍历过程中，另一个线程对该list进行了结构性修改(即modcount改变)，//java将会抛出ConcurrentModificationException异常，也就是fail-fast机制.protected transient int modCount = 0; 三 Stack构造函数12//Stack就只有一个默认构造函数，Stack不支持Vector的各种制定参数的构造方法。public Stack() &#123;&#125; 四 Stack方法之 增1234567//入栈方法,把元素添加到Stack最后一个位置public E push(E item) &#123; //实际上调用了父类Vector的addElement方法, //addElement()和push()方法本质上没有任何差别。 addElement(item); return item; &#125; 1234567//父类的addElement方法如下public synchronized void addElement(E obj) &#123; modCount++; //判断是否需要自动扩充数组 ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj;&#125; 五 Stack方法之 查1 peek()方法12345678 //该方法查询出Stack的最后一个元素,但是不删除该元素public synchronized E peek() &#123; int len = size(); if (len == 0) //如果Stack为空则抛出EmptyStackException异常 throw new EmptyStackException(); return elementAt(len - 1);&#125; 2 search(Object o)方法12345678public synchronized int search(Object o) &#123; //lastIndexOf()方法下面会说. int i = lastIndexOf(o); if (i &gt;= 0) &#123; return size() - i; &#125; return -1;&#125; ​ 父类的lastIndexOf()方法 123456789101112131415161718//该方法返回Object o 在Stack中最后一个出现的位置public synchronized int lastIndexOf(Object o, int index) &#123;//判断是否越界 if (index &gt;= elementCount) throw new IndexOutOfBoundsException(index + " &gt;= "+ elementCount); //分为不为空两种情况 if (o == null) &#123; for (int i = index; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = index; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; 六 Stack方法之 改​ Stack没有提供专属的修改方法，修改方法继承父类Vector。 七 Stack方法之 删123456789public synchronized E pop() &#123; E obj; int len = size(); //通过peek()方法返回Stack最后一个元素 obj = peek(); //移除Stack数组的最后一个元素 removeElementAt(len - 1); return obj;&#125; 八 优点​ Stack提供了出栈（pop）、入栈（push）等方法来实现栈数据结构，并且Stack是全线程安全的，所有方法都上了同步锁。 九 缺点​ 1、Stack由于继承了Vector类，导致其所有方法都加了同步锁，使得运行效率低下。 ​ 2、Stack和Vector一样作为远古时期的JDK类，属于即将被时代所淘汰的产物，官方并不建议使用这两个类。 ​ 若果你需要在多线程下使用Vector类，请使用以下替代品： ​ a、java.util.concurrent.CopyOnWriteArrayList ​ b、Collections.synchronizedList ​ 若果你要使用Stack类，请使用以下替代品： ​ 非多线程： ​ a、linkedList ​ 多线程： ​ b、java.util.concurrent.ConcurrentLinkedDeque ​ c、java.util.concurrent.ConcurrentLinkedQueue ​ d、ArrayDeque 十 总结​ Stack是基于数组实现的线程安全的栈结构，但是由于时代的演化，不建议大家使用该类进行业务开发，抛弃它吧！ ​​​]]></content>
      <categories>
        <category>计算机</category>
        <category>Java</category>
        <category>干了这杯源码</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合框架</tag>
        <tag>源码</tag>
        <tag>List</tag>
        <tag>Stack</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【干了这杯源码】集合框架 List之Vector（四）]]></title>
    <url>%2F2018%2F11%2F19%2F%E3%80%90%E5%B9%B2%E4%BA%86%E8%BF%99%E6%9D%AF%E6%BA%90%E7%A0%81%E3%80%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-List%E4%B9%8BVector%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Vector概述 ​ Vector来自于远古的JDK1.0，属于上古时期的类，因为其所有方法都上了同步锁，所以性能会比ArrayList低很多。​ Vector和ArrayList一样实现了可自动扩充的数组，都可根据下标直接访问元素，另外Vector可以根据需求改变自动增长的策略，默认每次增为原来的一倍。​ Vector是线程安全的，扫一眼源码你会发现，Vector很多方法都加了synchronized关键字，确保了线程的安全性。数据结构：数组 Vector的属性1 elementData12//该属性为Object类型的空数组，是Vector的底层存储数组protected Object[] elementData; 2 elementCount12//Vector的实际元素个数(等同于其他集合的size)protected int elementCount; 3 capacityIncrement12//capacityIncrement为Vector每次自动增长的大小，若capacityIncrement小于等于0，则按默认自动扩充为原来的1倍。protected int capacityIncrement; 4 modCount12//modCount属性为list被结构性修改的总次数protected transient int modCount = 0; 结构性修改(structurally modified)为改变size大小的操作，如add()、remove()等。modCount属性继承于父抽象类AbstractList。modCount属性的主要用于确保iterator遍历的准确性，防止多个线程对该list进行操作，如果在iterator遍历过程中，另一个线程对该list进行了结构性修改(即modcount改变)，java将会抛出ConcurrentModificationException异常,也就是fail-fast机制。 Vector构造函数1 无参构造函数1234//若为无参构造函数则自动调用Vector(int initialCapacity),其中initialCapacity==10public Vector() &#123; this(10);&#125; 2 initialCapacity为参数的构造函数1234//若调用此构造方法，则自动调用Vector(int initialCapacity, int capacityIncrement)方法，其中capacityIncrement=0public Vector(int initialCapacity) &#123; this(initialCapacity, 0);&#125; 3 initialCapacity和capacityIncrement为参数的构造函数12345678910public Vector(int initialCapacity, int capacityIncrement) &#123; super(); //initialCapacity不能小于0 if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); //赋值给elementData this.elementData = new Object[initialCapacity]; //赋值给capacityIncrement this.capacityIncrement = capacityIncrement;&#125; Vector方法 – 查询12345//查询元素下标public int indexOf(Object o) &#123; //调用indexOf(Object o, int index) 方法，index参数为0 return indexOf(o, 0);&#125; 1234567891011121314//查询元素o下标，并从index位置开始查找public synchronized int indexOf(Object o, int index) &#123; //分o为null和不为null两种情况 if (o == null) &#123; for (int i = index ; i &lt; elementCount ; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = index ; i &lt; elementCount ; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; Vector方法 – 增Vector新增有两个方法，一个是add，一个是addElement，他们两个的唯一区别就是返回值的不同。 1 add(E e)方法12345678//add()方法返回布尔值public synchronized boolean add(E e) &#123; modCount++; //检查是否需要扩容 ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125; 2 addElement(E obj)方法1234567//addElement()方法没有返回值public synchronized void addElement(E obj) &#123; modCount++; //检查是否需要扩容 ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj;&#125; Vector方法 – 改12345678910//将Vector下标为index的元素替换成elementpublic synchronized E set(int index, E element) &#123; //判断下标是否合法 if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); //记录即将被替换的旧元素 E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; Vector方法 – 删1 删除指定元素 removeElement（Object obj）1234567891011public synchronized boolean removeElement(Object obj) &#123; modCount++; //找到要删除元素obj的下标 int i = indexOf(obj); //如果存在，则调用removeElementAt()方法删除该元素 if (i &gt;= 0) &#123; removeElementAt(i); return true; &#125; return false;&#125; 2 删除指定下标的元素 removeElementAt(int index)123456789101112131415161718192021public synchronized void removeElementAt(int index) &#123; modCount++; //判断下标是否合法 if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + " &gt;= " + elementCount); &#125; //判断下标是否小于0 else if (index &lt; 0) &#123; throw new ArrayIndexOutOfBoundsException(index); &#125; //j为要删除的元素的下标位置 int j = elementCount - index - 1; //j&gt;0既删除的元素不是最后一个 if (j &gt; 0) &#123; //将数组从要删除的元素位置开始往前移，覆盖掉要删除的元素 System.arraycopy(elementData, index + 1, elementData, index, j); &#125; elementCount--; //让数组最后一个元素指向null，gc自动回收机制开始工作 elementData[elementCount] = null; /* to let gc do its work */ &#125; Vector优点1. 相当于线程安全的ArrayList 2. 可自动扩容 Vector缺点 因为线程太安全，所以性能极差 ​ 总结​ Vector这个类目前已经很少人使用，慢慢将会被历史抛弃，大家有兴趣就了解一下。目前如果有业务需要用到线程安全的可扩充数组，首选还是选用同步过后的ArrayList，同步的方法有Collections.synchronizedList和CopyOnWriteArrayList两种。]]></content>
      <categories>
        <category>计算机</category>
        <category>Java</category>
        <category>干了这杯源码</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合框架</tag>
        <tag>源码</tag>
        <tag>List</tag>
        <tag>Vector</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【干了这杯源码】集合框架 List之LinkedList（三）]]></title>
    <url>%2F2018%2F11%2F03%2F%E3%80%90%E5%B9%B2%E4%BA%86%E8%BF%99%E6%9D%AF%E6%BA%90%E7%A0%81%E3%80%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-List%E4%B9%8BLinkedLIst%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LinkedList概述 LinkedList 继承List接口，继承了List所有的方法。 LinkedList 允许存入任意类型的元素（包括null）。 LinkedList 继承了Deque接口（双端队列），该接口提供了一些方法，让我们可以获取、删除、插入队头或者队尾的元素。 LinkedList 是线程非安全的，你可以从外部自己加同步锁，也可以使用Collections.synchronizeList()方法对LinkedList进行包装。用法Collections.synchronizeList(new LinkedList)。 数据结构jdk1.6之前LinkedList采用一个固定头结点的双向循环链表作为结构（头结点的元素为null）。 12//头结点的初始化private transient Entry&lt;E&gt; header = new Entry&lt;E&gt;(null,null,null); jdk1.6之后LinkedList进行了改版，由原来带头结点的==循环双向链表==改为不带头结点的==双向链表==，分别采用first和last两个指针指向链表首尾结点。 1234//first指针初始化，默认等于null，既指向nulltransient Node&lt;E&gt; first;//last指针初始化,默认等于null，既指向nulltransient Node&lt;E&gt; last; LinkedList的属性0 Node1234567891011121314//Node代表着LinkedList的每一个结点，是LinkedList的静态内部类。//jdk1.6之前，结点名称叫Entry//jdk1.6之后，结点名称叫Nodeprivate static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 1 size12//LinkedList的实际元素个数private int size; 2 first12345//指向首节点的指针//满足以下恒等式：//(first == null &amp;&amp; last == null) ||// (first.prev == null &amp;&amp; first.item != null)transient Node&lt;E&gt; first; 3 last12345//指向尾结点的指针//满足以下恒等式：//(first == null &amp;&amp; last == null) ||// (last.next == null &amp;&amp; last.item != null)transient Node&lt;E&gt; last; 4 modCount12//modCount属性为list被结构性修改的总次数protected transient int modCount = 0; 结构性修改(structurally modified)为改变size大小的操作，如add()、remove()等。modCount属性继承于父抽象类AbstractList。modCount属性的主要用于确保iterator遍历的准确性，防止多个线程对该list进行操作，如果在iterator遍历过程中，另一个线程对该list进行了结构性修改(即modcount改变)，java将会抛出ConcurrentModificationException异常,也就是fail-fast机制。 LinkedList构造函数1 无参构造函数123//无参构造函数，因为first和last指针初始都为null，//所以该方法内没必要指定first和last的值。 public LinkedList() &#123;&#125; 2 Collection为参数的构造函数1234public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; addAll(Collection c)方法内部调用了addAll(int index, Collection c)方法 123public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//该方法为在LinkedList的指定位置插入Collectionpublic boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; //检查插入的位置是否合法 checkPositionIndex(index); //把Collection转化为Object数组 Object[] a = c.toArray(); //numNew为Collection的元素个数 int numNew = a.length; //若没有元素则返回false if (numNew == 0) return false; //pred代表下标为index结点的前一个结点 //succ代表下标为index的结点 Node&lt;E&gt; pred, succ; //如果插入的位置等于LinkedList本身的大小， //既在LinkedList最后一个位置插入（若没有元素，则在第一位） if (index == size) &#123; //因为在LinkedList最后插入，所以插入下标index没有元素 succ = null; //pred最后一个结点 pred = last; &#125; else &#123; //在LinkedList中间插入Collection //succ等于下标结点 succ = node(index); //pred等于下标结点的前一个 pred = succ.prev; &#125; //插入元素，遍历数组，让链表指向依次改变 for (Object o : a) &#123; @SuppressWarnings("unchecked") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; //插入完之后，判断是否在尾部插入 if (succ == null) &#123; //尾部插入，last指针指向pred即可 last = pred; &#125; else &#123; //中部插入，需要连接被切开的后端部分 //让pred的后继指针指向被切开的下标结点 pred.next = succ; //让被切开的下标结点succ前驱指针指向pred succ.prev = pred; &#125; size += numNew; modCount++; return true;&#125; LinkedList方法 – 查询123456public E get(int index) &#123; //检查下标是否合法 checkElementIndex(index); //调用node(index)方法获取以index下标的结点 return node(index).item;&#125; 1234567891011121314151617//获取idnex下标结点Node&lt;E&gt; node(int index) &#123; // 判断index是否小于size的一半（此处采用右移运算符，提高计算效率） // 若index小于size的一半，则从链表第一个开始遍历 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; //若index大于size的一半，则从链表尾部往前遍历 Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; LinkedList方法 – 增我们在构造函数的时候已经介绍了addAll()方法，相对而言add()就显得简单许多。 12345//LinkedList末尾插入元素public boolean add(E e) &#123; linkLast(e); return true;&#125; 12345678//LinkedList中部插入元素public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125; ​ 上面两个插入方法都调用了linkLast(element) 12345678910111213141516void linkLast(E e) &#123; //定义l结点为LinkedList的最后一个元素 final Node&lt;E&gt; l = last; //定义newNode结点的前驱结点为l，元素为e，后继为null final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //让last指针指向newNode结点 last = newNode; if (l == null) //l结点为null代表LinkedList没有元素 first = newNode; else //反之则l结点的后继指针指向newNode l.next = newNode; size++; modCount++;&#125; LinkedList方法 – 改12345678//直接替换结点的元素，不需要改变指针指向public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125; LinkedList方法 – 删12345public E remove(int index) &#123; checkElementIndex(index); //调用unlink方法 return unlink(node(index));&#125; 123456789101112131415161718192021222324252627//删除方法也容易理解//1、将被删除结点的前驱结点的后继指针指向删除结点的后继结点//2、将被删除结点的后继结点的前驱指针指向删除结点的前驱结点E unlink(Node&lt;E&gt; x) &#123; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; LinkedList优点​ 1.插入和删除元素效率高，不需要像ArrayList一样移动数组。​ 2.可以被当做栈和队列使用 LinkedList缺点​ 1.根据下标遍历元素效率低。​ 2.根据下标访问元素效率低。​ 3.根据下标修改元素效率低。​ 4.结点占有的空间比ArrayList多，因为除了元素本身，保存了前驱后继指针。 总结​ LinkedList是基于链表实现的双向链表（循环），因此LinkedList具有链表所具有的优缺点，既插入、删除元素高效，而指定下标查询和修改元素效率低下。​ LinkedList是线程非安全的，只能在单线程的环境下使用。可以采用该方法解决Collections.synchronizedList。​ LinkedList的优势在于插入和删除元素只需移动指针，固需要频繁进行插入和删除操作时，LinkedList应当首选。]]></content>
      <categories>
        <category>计算机</category>
        <category>Java</category>
        <category>干了这杯源码</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合框架</tag>
        <tag>源码</tag>
        <tag>List</tag>
        <tag>LinkedList</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【干了这杯源码】集合框架 List之ArrayList（二）]]></title>
    <url>%2F2018%2F11%2F02%2F%E3%80%90%E5%B9%B2%E4%BA%86%E8%BF%99%E6%9D%AF%E6%BA%90%E7%A0%81%E3%80%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-List%E4%B9%8BArrayList%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ArrayList概述 ​ ArrayList的底层数据结构为数组，实现了List接口，允许传入所有类型的元素(包括null)。​ ArrayList内部提供了方法，对数组的大小进行自动扩充。​ ArrayList进行add方法时，时间复杂度为O(n)，其他操作方法的时间复杂度为O(1)(粗略地讲)。​ 每一个ArrayList实例都包含一个capacity(容量)，这个capacity用来记录数组的size(实际元素个数)，并且满足条件capacity≥size。当一个元素被添加进ArrayList时，size加1，capacity会判断是否进行扩充。​ ArrayList是线程非安全的，如果多个线程同时对ArrayList进行结构性操作（增删），一定要在外部加上同步锁。​ ArrayList除了是线性非安全之外，粗略的等价于Vector类。 数据结构 : 数组 线程安全 : 非线程安全​ 解决办法 Collections.synchronizedList &amp; CopyOnWriteArrayList 两种​ CopyOnWriteArrayList 写操作性能较差，而读操作性能较好​ Collections.synchronizedList 写的操作好，因为加了锁的原因，读较差 ArrayList的属性1 DEFAULT_CAPACITY12//该属性为默认的初始容量private static final int DEFAULT_CAPACITY = 10; 2 EMPTY_ELEMENTDATA12//该属性为Object类型的空数组private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; 3 DEFAULTCAPACITY_EMPTY_ELEMENTDATA12//该属性为Object类型的空数组,用于未指定初始大小的实例private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; 你可能会问,为什么有了EMPTY_ELEMENTDATA，之后还要单独再弄一个DEFAULTCAPACITY_EMPTY_ELEMENTDATA?这么做的作用是区分出elementData是从什么地方初始化的，是无参构造函数还是有参构造函数。 4 elementData12//该属性为缓存数组transient Object[] elementData; ArrayList新增元素时，新增的元素会保存到该缓存数组中，该缓存数组的大小为capacity，当使用无参构造函数后（大家可以看看下面无参构造的具体代码），既elementDate==DEFAULTCAPACITY_EMPTY_ELEMENTDATA，当ArrayList首次使用add方法时，会扩充成为elementData的大小会自动变为DEFAULT_CAPACITY。 5 size12//ArrayList的实际元素个数private int size; 6 modCount12//modCount属性为list被结构性修改的总次数protected transient int modCount = 0; 结构性修改(structurally modified)为改变size大小的操作，如add()、remove()等。modCount属性继承于父抽象类AbstractList。modCount属性的主要用于确保iterator遍历的准确性，防止多个线程对该list进行操作，如果在iterator遍历过程中，另一个线程对该list进行了结构性修改(即modcount改变)，java将会抛出ConcurrentModificationException异常,也就是fail-fast机制。 ArrayList构造函数1 无参构造函数123public ArrayList() &#123; this.elementData = EFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 当调用此构造函数时，缓存数组(elementData)将会被赋值为DEFAULTCAPACITY_EMPTY_ELEMENTDATA，并且初始化长度为DEFAULT_CAPACITY 2 initialCapacity参数构造函数123456789public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: " + initialCapacity); &#125; &#125; 3 Collection为参数的构造函数1234567891011public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; 细心的你可能会注意到这段注释 1// c.toArray might not return Object[] (see 6260652) 意思是c.toArray的返回值可能不会 ArrayList方法1 查询1234public E get(int index) &#123; rangeCheck(index);//检查下标是否合法 return elementData(index);//直接返回数组的下标&#125; ​ 该方法实现较为简单,只需检测传入的index值是否合法 2 增1234567891011121314151617//为list添加特定元素到特定位置,并且插入时自动右移数组public void add(int index, E element) &#123; //检测传入的index是否在正确范围之内 rangeCheckForAdd(index); //判断size+1和elementData.length谁大，如果size+1比elementData.length大， //则调用grow(int minCapacity)方法，grow方法若符合条件，则elementDate自动扩充为原来的1.5倍， //有兴趣的同学可以自己去查阅grow的源码。 ensureCapacityInternal(size + 1); //该方法实现了数组后移的操作，System.arraycopy()方法被native修饰符修饰， //底层是调用C语言的memmove()方法， //特别是对性能要求苛刻的开发，更适合用此方法! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; 3 改1234567//特换特定位置的元素，同样检测index是否合法，返回被替换的元素public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 4 删​ 根据下标删除元素，返回被删除的元素​ 12345678910111213141516public E remove(int index) &#123; //检测传入的index是否在正确范围之内 rangeCheck(index); //总操作数+1 modCount++; E oldValue = elementData(index); //记录数组中要移动的元素个数 int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // clear to let GC do its work // size-1，并且让数组最后一位为空 elementData[--size] = null; return oldValue;&#125; ArrayList优点​ 1.根据下标遍历元素效率高。​ 2.根据下标访问元素效率高。​ 3.在数组的基础上封装了各种对元素操作的方法。​ 4.当数组容量不足时,ArrayList会对数组自动扩容0.5倍。 ArrayList缺点​ 1.由于数组的原因,插入和删除元素效率低。​ 2.根据元素查找元素效率低。 总结​ ArrayList是基于数组实现的动态数组，其容量会在每次执行add操作时会在内部进行ensureCapacity()判断，若符合条件则自动扩容0.5倍。​ ArrayList是线程非安全的，只能在单线程的环境下使用。解决办法有Collections.synchronizedList和CopyOnWriteArrayList两种，分别有各自的特点。​ ArrayList的优势在于通过下标快速访问元素效率高，倘若需要频繁进行插入和删除操作时，ArrayList不是首选。]]></content>
      <categories>
        <category>计算机</category>
        <category>Java</category>
        <category>干了这杯源码</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合框架</tag>
        <tag>源码</tag>
        <tag>List</tag>
        <tag>ArrayList</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【干了这杯源码】集合框架 Collection接口介绍（一）]]></title>
    <url>%2F2018%2F10%2F08%2F%E3%80%90%E5%B9%B2%E4%BA%86%E8%BF%99%E6%9D%AF%E6%BA%90%E7%A0%81%E3%80%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-Collection%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Collection接口概述​ Collection是集合框架的根接口(root interface)，一个Collection代表了一组元素的集合，一部分Collection允许元素重复、有序排列，一部分则相反，在JDK中没有提供任何直接实现Collection的实现类，但是提供了很多特异性的子接口，例如Set、List和Queue，这些子接口将会极大程度地覆盖日常开发使用的情景。 所有实现Collection接口的实现类都包含了两个构造器: 1.无参构造器 2.参数为Collection的构造器(该构造器将会构造出与参数Collection元素相同的集合) 值得注意的是，此处并无方法强制去规定实现类要包含这两个构造器(因为接口不能定义构造器)，但是所有的Collection实现类都遵循了这项规定。 ​ 一些Collection的实现类对元素进行了限制。比如,有些Collection实现类禁止null元素，有些则限制了元素的类型。一旦企图去添加无资格(ineligible)的元素将会抛出非检查型异常(Unchecked Exception) ,企图去查询无资格(ineligible)的元素也有有可能会抛出异常，或者直接return false。 ​ 另外，集合是否线程安全取决于每个集合自身的同步策略。当这个集合缺乏一个强有力的线程保护时。 Collection全家桶 List接口​ 是一个有序、可重复、可为null的集合接口 List接口常用实现类为三个 ： 1、ArrayListList接口中最实用的实现类，底层由数组构成 2、LinkedListLinkedList的数据结构是双向链表。它也可以被当作堆栈、队列或双端队列进行操作。 3、Vector通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。 3.1、StackStack类表示后进先出（LIFO）的对象堆栈。 Set接口不允许元素重复，集合元素唯一(元素可以为null)，无序。 Set接口常用实现类为 1、HashSetHashSet使用哈希表（hash table）实现的，其中的元素是无序的 1.1、LinkedHashSetLinkedHashSet介于HashSet和TreeSet之间。它基于一个由链表实现的哈希表，保留了元素插入顺序。 2、TreeSetTreeSet使用树形结构（红黑树）实现的，TreeSet中的元素是可排序的。 3、EnumSetEnumSet是一个专为枚举类设计的集合类，EnumSet中所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式或隐式地指定。EnumSet的集合元素也是有序的，EnumSet以枚举值在Enum类的定义顺序来决定集合元素的顺序。 Queue接口queue接口用于模拟队列数据结构,采用”先进先出”的方式 Deque数据结构为双端队列 Queue接口常用实现类为1.PriorityQueuePriorityQueue为优先队列，它的逻辑结构是一课完全二叉树（堆），存储结构其实是一个数组，具有堆的特点，可以实现小顶堆和大顶堆 2.ArrayQueueArrayQueue为基于数组实现的队列 3.LinkedListLinkedList为基于链表实现的队列 总结以上是Collection接口常用子接口及其常用实现类的介绍，有一点值得注意的是，Map接口虽然被理论上归入集合框架，但是于Collection并无交集，独立出来。]]></content>
      <categories>
        <category>计算机</category>
        <category>Java</category>
        <category>干了这杯源码</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合框架</tag>
        <tag>源码</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【干了这杯源码】集合框架 数据结构（零）]]></title>
    <url>%2F2018%2F10%2F08%2F%E3%80%90%E5%B9%B2%E6%BA%90%E7%A0%81%E3%80%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%20%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E9%9B%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[概述​ 本专题将会给大家来带Java最实用的东西—集合框架，并将会直接从源码入手，直接干源码！由于集合框架的底层离不开数据结构，想搞清楚List、Set、Map等的底层实现，必须先从数据结构开始讲起。所以开山第一篇，将会给大家介绍计算机的数据结构。 ​ 数据结构可以说是计算机入门必修课程，同时也是特别烧脑的纯理论知识。所以本篇将会尽量避开让人看不懂的奇奇怪怪的东西，以生动形象的图文并茂带你窥探神秘的数据结构。 什么是数据结构？ 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。 –《百度百科》 科学家和人类应该不是一个物种，他们定义的名词读起来都比较拗口、而且十分不好理解。 什么是数据结构，举个通俗易懂的例子： 比如在现实世界里，你、我、其他所有人都属于数据元素，我们每个人之间都存在着错综复杂的关系。就好比：你是大名鼎鼎的太子、拥有至高无上的权利和无尽的财富，而我是个小小的皇上，我们之间就所形成的关系就是数据结构。 数据结构分为三个部分 可能有人会有疑问，数据结构和算法有什么关系呢？其实，数据结构和算法是相辅相成的，在计算机领域里面，谁也离不开谁。倘若失去了数据结构，算法会显得无比空洞；抛开算法，数据结构将会变成摆设！本篇将主要介绍逻辑结构和物理结构，至于算法会在后续章节，具体问题详细分析。 一、逻辑结构逻辑结构简单来说是指数据元素之间的前后件关系，主要包括4类。 1.集合结构数据结构之间除了“属于同集合” 的关系外，别无其他关系。 上图所有人（数据元素）同属于一个皇宫（集合） 2.线性结构数据结构之间的元素是一对一的关系。 上图为一对一的线性结构，例子：数组、链表、栈和队列 3.树形结构数据结构之间的元素存在一对多的相互关系 上图所示为一对多的树形结构，举例：二叉树、红黑树 4.图形结构数据结构中的元素存在多对多的相互关系。 如上图所示，虽关系略微复杂，却反映出图形结构多对多的关系。 ​ 二、物理结构指数据的逻辑结构在计算机存储空间的存放形式。 （提醒：该部分为本篇的重点，也是后面篇章讲解集合框架所依赖的东西。本篇将由浅入深、循序渐进，后面在具体讲到某 一个具体集合类时，会结合具体的方法来解读对应的储存结构） 通常来说数据的物理结构分为四类： 1.顺序存储结构把逻辑上相邻的结点存储在物理位置上相邻的存储单元中，结点之间的逻辑关系由存储单元的邻接关系来体现。 好比↑：国王和士兵们一起去菜市场排队买苹果，此时他们排成一对，紧紧的站在一起，就形成了一个顺序存储结构。 优点：查询元素效率高 因为顺序存储结构在逻辑和物理都是相邻的排序，所以找第几个士兵，直接就可以定位到目标。 缺点：插入和删除元素效率低(随机位置) 由于此结构的特性，每次插入和删除都要使整一个存储结构前移或者后移，相当影响性能。 举个例子↓，假设你是大名鼎鼎的太子，拥有至高无上的权利和地位，你路过菜市场，看到大家都在排队买苹果，你也跟风要买。你不仅要买还要插队，大家没办法只能默默的往后退一步，让出第一的位置给你，这过程体现了顺序存储结构插入的效率低下。 删除元素也同理↓，国王在队伍后面目睹了这一切，下令处死太子，太子就被拉出去枪毙了，大家又依次往前一步。 2.链式存储结构在计算机中用一组任意的存储单元存储线性表的数据元素，结点间的逻辑关系是由附加的指针字段表示。简单来讲，逻辑上相邻的数据元素，在物理结构上可以随意存放，不要求物理结构相邻，同时每个逻辑相连的元素手里都拿着一把指针指向下一个元素。 就比如↑：国王和太子们乘坐搭巴士，上了巴士之后不一定要找两个相邻的位置，有位置就可以坐。国王只需记住第一个太子的位置，每一个太子都只记着下一个太子的位置，就形成了一个链式储存结构。 优点：插入和删除元素效率高(随机位置) 如上图所示↓，如果此时皇后也上了巴士，且皇后要坐在国王的下一个位 置，那么只需要将国王的指针指向皇后，皇后的指针指向A太子，就插入成功！ 缺点：查找元素效率低由于链式存储结构的特性，如果你要找到D太子，你必须先找到C太子，要找到C太子必须先找到B太子，以此类推，你要先找到国王，再从国王指引的方向一个一个找过去。 3.索引存储结构索引存储结构是用结点的索引号来确定结点存储地址,其优点是检索速度快,缺点是增加了附加的索引表,会占用较多的存储空间。 索引存储结构由于其除了数据元素本身之外，还额外创建索引表，索引表的每个节点包含了索引键值和指针，如下图所示↓（以二叉树为索引表） 国王记性不好，记不住每一个人的地址，所以额外创建了一个索引表，方便快速定位。比如今晚想找尼姑一起研究数据结构，不用一个一个房间去敲门，只需要找到索引表的尼姑，就可以找到尼姑的具体地址。 优点：数据检索的速度快 缺点： 创建索引需要占用物理空间和消耗时间 对数据元素进行维护的同时，索引表也需要进行维护，影响性能 4.散列存储结构定义：实质上就是通过节点的关键字，再通过某一特定的计算，算出该关键字对应的物理地址。 散列（哈希）表：用散列法存储的线性结构被称为散列表或者哈希表，使用的函数f(k)被称为散列函数或者哈希函数，f(k)的值被称为散列地址或者哈希地址。通常情况下，散列表的存储空间是一个一维数组，而其哈希地址为数组的下标。 举个栗子：国王希望将皇宫内所有女性，按照某些指数，进行计算、分类如下图↓ 将每个节点元素通过散列函数f(k)计算出地址，并存放到相应的位置，如此就形成了哈希表。 比如查询”尼姑”数据是否存在时，只需要根据”尼姑”的”三围”，计算出”尼姑”的地址C，即可直接获取尼姑。 优点：散列结构的查找、插入、删除效率高。 缺点: 不支持排序、比用线性表存储需要更多的空间、基于数组的散列表扩展比较麻烦。 （笔者感慨：散列存储结构可以说是一件艺术品，在这里不得不佩服科学家们。网上有一种说法：Hash是一名科学家，由他提出了散列算法，所以命名为Hash算法。可是查无此人，知道的可以留言告诉我一下） 三、算法​ 后面章节会具体简介 总结本篇内容可以总结为下图 数据结构的应用： 这些内容可以说是古代劳动人民智慧的结晶，很多数据结构我们都可以直接拿来用。但是！这些计算机底层的东西，一定不能被动地记忆，要辩证地思考，上面的一切都不是真理，可能随着时间会慢慢被改进或者淘汰。]]></content>
      <categories>
        <category>计算机</category>
        <category>Java</category>
        <category>干了这杯源码</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合框架</tag>
        <tag>源码</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
