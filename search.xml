<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基础算法排序 - 插入排序]]></title>
    <url>%2F2018%2F12%2F07%2F%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%20-%20%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[插入排序一 概念​ 有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用插入排序法。 ​ 插入排序是最简单的排序算法之一，他的核心是将一个新数据插入到已经排好序的有序数据中，从而得到一个新的、个数+1的有序数据。 ​ 插入排序算法适用于少量数据的排序，时间复杂度为$O(n^2)$。 二 实现原理​ 我们先来看一个问题。一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，我们只要遍历数组，找到数据应该插入的位置将其插入，后面的后移即可。 ​ 按照上面的原理，我们很容易按照上面的思想对一个杂乱的数列进行排序。 ​ 首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间。 ​ 初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。 ​ 如图所示，左边绿色的是已经排好序的序列，右边橙色是未排序的序列。 ​ 因此我们可以发现，插入排序包含了两个操作，一个是元素的比较，一个是元素的移动。 ​ 当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。 三 实现代码-java1 未优化版12345678910111213141516171819202122232425public static void main(String[] args) &#123; int arr[]=&#123;7,3,9,4,5,2,1&#125;; //第一步遍历整个数组arr for( int i = 1; i &lt; arr.length; i++ )&#123; //第二步遍历arr中的已排好序数组(若第一次遍历,则取第一个元素作为已排好序的数组) for(int j = 0;j&lt;=i-1;j++)&#123; //第三步从排好序的数组首位j开始比较, //如果arr[i]比arr[j]还要小,则进入if(将排好序的数组从插入位置开始依次往后移动一个位置) if(arr[i]&lt;=arr[j])&#123; //key为临时存储arr[i]的变量 int key = arr[i]; //依次右移 for(int k = i-1;k&gt;=j;k--)&#123; arr[k+1] = arr[k]; &#125; //插入到目标位置! arr[j]=key; break; &#125; &#125; &#125; for(int i : arr)&#123; System.out.print(i + " "); &#125;&#125; 2 优化版​ 上面代码是我自己纯手写的，运行没问题，结果没问题。可是细心的你可能发现了，不对劲啊，明明插入排序的时间复杂度是$O(n^2)$硬生生被我写成了$O(n^3)​$，为什么会这样呢？ ​ 经过了我的深思熟虑，我发现问题了。其实可以代码还可以优化，通过我原先代码的注释中的第三步： 1//第三步从排好序的数组首位j开始遍历 ​ 此处逻辑应该为 “从排好序的数组的最后一位i-1开始遍历”，代码如下： 123456789101112131415161718192021222324public static void main(String[] args) &#123; int arr[]=&#123;7,3,9,4,5,2,1&#125;; //第一步遍历整个数组arr for( int i = 1; i &lt; arr.length; i++ )&#123; //key为临时存储arr[i]的变量 int key = arr[i]; int j = i-1; //第二步遍历arr中的已排好序数组(若第一次遍历,则取第一个元素作为已排好序的数组) for(;j&gt;=0;j--)&#123; //第三步从排好序的数组最后一位i-1开始比较,如果key比arr[j]还要小 if(key&lt;=arr[j])&#123; //单独右移 arr[j+1] = arr[j]; &#125;else&#123; break; &#125; &#125; //插入到目标位置,注意此处是j+1! arr[j+1]=key; &#125; for(int i : arr)&#123; System.out.print(i + " "); &#125;&#125; 上面运行得出结果和之前的一致，但是时间复杂度却减低了一次方！]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【干了这杯源码】集合框架 Queue之PriorityQueue（七）]]></title>
    <url>%2F2018%2F12%2F04%2F%E3%80%90%E5%B9%B2%E4%BA%86%E8%BF%99%E6%9D%AF%E6%BA%90%E7%A0%81%E3%80%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-Queue%E4%B9%8BPriorityQueue%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[PriorityQueue一 概述​ PriorityQueue(优先队列)，实现了小顶堆（大顶堆），它的逻辑结构是一棵完全二叉树，存储结构其实是一个数组。逻辑结构层次遍历的结果刚好是一个数组。​ PriorityQueue的元素根据自然顺序排序，如果重写了Comparator接口方法，则按照重写的新规则排序，不允许存入null元素。​ PriorityQueue的队头元素是整个队列中最小的一个，如果有多个最小的元素，队列的头部将会取其中一个。​ PriorityQueue的容量理论上是无限的，但是队列内部有一个capacity统治着整个内部数组，这个capacity至少大于队列的大小，当一个元素被添加进来时，他的capacity将会自动增加，且增长策略无法指定。 ​ 如果我们需要控制某个类的次序并且该类本身不支持排序，那么就可以建立一个类比较器来进行排序，实现方式很简单只需要实现java.util.Comparator接口。 二 PriorityQueue属性1 DEFAULT_INITIAL_CAPACITY12//表示队列内部的数组默认大小为11 private static final int DEFAULT_INITIAL_CAPACITY = 11; 2 queue12345//优先队列的逻辑结构为排好序的二叉树，//逻辑结构层次遍历的结果刚好是一个数组，二叉树的两个子节点在数组上的位置//分别为queue[2*n+1] 和 queue[2*(n+1)]//对于每一个n的后代d都满足等式：n&lt;=dtransient Object[] queue; 3 size12//优先队列的具体元素个数 private int size = 0; 4 comparator12//自定义的比较器，如果为空则按照默认的自然排序法private final Comparator&lt;? super E&gt; comparator; 5 modCount12//优先队列被结构性修改的次数transient int modCount = 0; 三 PriorityQueue构造函数1 无参构造函数1234//生成一个初始大小为11的队列，且comparator为nullpublic PriorityQueue() &#123; this(DEFAULT_INITIAL_CAPACITY, null);&#125; 2 initialCapacity参数构造函数1234//生成一个指定初始大小的优先队列，且comparator为nullpublic PriorityQueue(int initialCapacity) &#123; this(initialCapacity, null);&#125; 3 comparator参数构造函数1234//生成一个指定初始大小的优先队列，且comparator为nullpublic PriorityQueue(Comparator&lt;? super E&gt; comparator) &#123; this(DEFAULT_INITIAL_CAPACITY, comparator);&#125; 4 initialCapacity、comparator参数的构造函数12345678public PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) &#123; // 传入的初始大小至少大于等于1 if (initialCapacity &lt; 1) throw new IllegalArgumentException(); this.queue = new Object[initialCapacity]; this.comparator = comparator;&#125; 5 Collection参数的构造函数12345678910111213141516public PriorityQueue(Collection&lt;? extends E&gt; c) &#123; if (c instanceof SortedSet&lt;?&gt;) &#123; SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c; this.comparator = (Comparator&lt;? super E&gt;) ss.comparator(); initElementsFromCollection(ss); &#125; else if (c instanceof PriorityQueue&lt;?&gt;) &#123; PriorityQueue&lt;? extends E&gt; pq = (PriorityQueue&lt;? extends E&gt;) c; this.comparator = (Comparator&lt;? super E&gt;) pq.comparator(); initFromPriorityQueue(pq); &#125; else &#123; this.comparator = null; initFromCollection(c); &#125;&#125; 四 PriorityQueue方法之 增1 offer()方法 1234567891011121314151617181920//插入元素 public boolean offer(E e) &#123; //如果插入的元素为null则抛出错误 if (e == null) throw new NullPointerException(); modCount++; int i = size; //若果size的长度大于等于queue的长度，则调用grow方法 if (i &gt;= queue.length) //自动增长 grow(i + 1); size = i + 1; if (i == 0) //如果为第一个元素则直接吧元素e放在queue[0]位置 queue[0] = e; else //调用堆自动排序方法siftUp siftUp(i, e); return true; &#125; 2 grow()方法12345678910111213//grow方法如下：private void grow(int minCapacity) &#123; int oldCapacity = queue.length; // Double size if small; else grow by 50% // 如果小于64则翻倍，反之则增长50% int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ? (oldCapacity + 2) : (oldCapacity &gt;&gt; 1)); // 这个处理是为了防止minCapacity过大，导致内存溢出 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); queue = Arrays.copyOf(queue, newCapacity); &#125; 3 siftUp()方法123456789//每次向PriorityQueue插入元素时候，会调用siftUp排序方法//实现效果如下图所示private void siftUp(int k, E x) &#123; //如果有定义比较器则使用比较器，没有则走else if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x);&#125; {% asset_img offer.png %} 五 PriorityQueue方法之 查1 peek()方法1234//直接获取队列的第一个元素，如果不存在则返回nullpublic E peek() &#123; return (size == 0) ? null : (E) queue[0];&#125; 2 poll()方法12345678910111213141516//该方法和peek有点像，都是返回一样的东西，但是poll方法放回出元素后会删除该元素//相当于过河拆桥public E poll() &#123; if (size == 0) return null; int s = --size; modCount++; E result = (E) queue[0]; E x = (E) queue[s]; queue[s] = null; if (s != 0) //删除完之后，因为改变了优先队列的结构，所以必须重新排序 //调用siftDown方法 siftDown(0, x); return result;&#125; 六 PriorityQueue方法之 删12345678//remove方法相当于删除队列的队头元素，实质上是调用了poll方法public E remove() &#123; E x = poll(); if (x != null) return x; else throw new NoSuchElementException();&#125; 七 总结​ 1 PriorityQueue是用数组实现，但是数组大小可以动态增加，容量无限。 ​ 2 PriorityQueue的实现不是同步的。不是线程安全的。如果多个线程中的任意线程从结构上修改了列表， 则这些线程不应同时访问 PriorityQueue实例。保证线程安全可以使用PriorityBlockingQueue 类。 ​ 3 不允许使用 null 元素。 ​ 4 此类及其迭代器实现了 Collection 和 Iterator 接口的所有可选 方法。 ​ 5 PriorityQueue对元素采用的是堆排序，头是按指定排序方式的最小元素。堆排序只能保证根是最大（最小），整个堆并不是有序的。方法iterator()中提供的迭代器可能只是对整个数组的依次遍历。也就只能保证数组的第一个元素是最小的。]]></content>
      <categories>
        <category>计算机</category>
        <category>Java</category>
        <category>干了这杯源码</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合框架</tag>
        <tag>源码</tag>
        <tag>Queue</tag>
        <tag>优先队列</tag>
        <tag>PriorityQueue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探索中间件 - 消息队列之RabbitMQ]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%8E%A2%E7%B4%A2%E4%B8%AD%E9%97%B4%E4%BB%B6%20-%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8BRabbitMQ%2F</url>
    <content type="text"><![CDATA[RabbitMQ一 什么是消息队列1 定义 ​ 消息队列（Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列互交。消息会保存在队列中，直到接收者取回它。 ——维基百科 消息队列是消费-生产者模型的典型实现，如下图所示： 2 特性2.1 异步性​ 将耗时的同步操作，通过以发送消息的方式，进行了异步化处理。减少了同步等待的时间。 2.2 松耦合​ 消息队列减少了服务之间的耦合性，不同的服务可以通过消息队列进行通信，而不用关心彼此的实现细节，只要定义好消息的格式就行。 2.3分布式​ 通过对消费者的横向扩展，降低了消息队列阻塞的风险，以及单个消费者产生单点故障的可能性（当然消息队列本身也可以做成分布式集群）。 2.4 可靠性​ 消息队列一般会把接收到的消息存储到本地硬盘上（当消息被处理完之后，存储信息根据不同的消息队列实现，有可能将其删除），这样即使应用挂掉或者消息队列本身挂掉，消息也能够重新加载。 二 消息队列的种类​ 目前市面上比较热门的消息队列有RabbitMQ 、RocketMQ 、Kafka 、activeMQ 、ZeroMQ。 1 RabbitMQ​ RabbitMQ是流行的开源消息队列系统，用erlang语言开发。RabbitMQ是AMQP（高级消息队列协议）的标准实现，在稳定性、可用性、安全性方面都很出色，而且入门也比较简单。 2 Rocket MQ​ RocketMQ是由阿里巴巴开发，并无偿捐赠给了apache软件基金会，性能方面也十分优秀。 3 Kafka​ Kafka是由apache软件基金会开发的，是一种高吞吐量的分布式发布订阅消息系统，它的高并发性能是这几个消息队列最优秀的，但是Kafka的开发定位主要使用在日志处理方面，具有极强的专一性，固常用于日志处理，少用于实际业务处理。​ 当你的项目需要技术选型的时候,建议采取用RabbitMQ 、RocketMQ 、Kafka的其中一个，activeMQ 、ZeroMQ这两个比较少使用。 三 为什么使用消息队列1 异步处理​ 场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种 ​ a.串行的方式； ​ b.并行方式;​ （a）串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端​ （2）并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间。 ​ 假设三个业务节点每个使用50毫秒钟，不考虑网络等其他开销，则串行方式的时间是150毫秒，并行的时间可能是100毫秒。 ​ 因为CPU在单位时间内处理的请求数是一定的，假设CPU1秒内吞吐量是100次。则串行方式1秒内CPU可处理的请求量是7次（1000/150）。并行方式处理的请求量是10次（1000/100）。​ 小结：如以上案例描述，传统的方式系统的性能（并发量，吞吐量，响应时间）会有瓶颈。如何解决这个问题呢？​ 引入消息队列，将不是必须的业务逻辑，异步处理。改造后的架构如下： 按照以上约定，用户的响应时间相当于是注册信息写入数据库的时间，也就是50毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是50毫秒。因此架构改变后，系统的时间效率比串行提高了3倍，比并行提高了两倍。 2 应用解耦​ 场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。如下图​ 传统模式的缺点： ​ a 假如库存系统无法访问，则订单减库存将失败，从而导致订单失败。​ b 订单系统与库存系统耦合。 如何解决以上问题呢？引入应用消息队列后的方案，如下图： ​ 订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功。 ​ 库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作。 ​ 假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦。 3 流量削锋​ 流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。 ​ 应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列，好处如下： ​ a 可以控制活动的人数。 ​ b 可以缓解短时间内高流量压垮应用。 ​ 用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面。 ​ 秒杀业务根据消息队列中的请求信息，再做后续处理。 4 日志处理​ 日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下： ​ 日志采集客户端：负责日志数据采集，定时写受写入Kafka队列。 ​ Kafka消息队列：负责日志数据的接收，存储和转发。 ​ 日志处理应用：订阅并消费kafka队列中的日志数据 以下是新浪kafka日志处理应用案例：转自（http://cloud.51cto.com/art/201507/484338.htm） (1)Kafka：接收用户日志的消息队列。 (2)Logstash：做日志解析，统一成JSON输出给Elasticsearch。 (3)Elasticsearch：实时日志分析服务的核心技术，一个schemaless，实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能。 (4)Kibana：基于Elasticsearch的数据可视化组件，超强的数据可视化能力是众多公司选择ELK stack的重要原因。 5 消息通讯​ 消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。 点对点通讯： 四 RabbitMQ工作原理1 工作原理图 2 Publisher​ Publisher指的是消息生产者，表示一个向消息队列发布消息的客户端应用程序。 3 Consumer​ Consumer消息的消费者，表示一个向消息队列中获取消息的客户端应用程序。 4 Broker​ Broker指RabbitMQ服务器的实体。 5 Virtual Host​ Virtual Host指RabbitMQ的虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个vhost本质上就是一个mini的RabbitMQ服务器，拥有自己的队列、交换器、绑定和权限机制。vhost是AMQP概念的基础，必须在连接时指定，RabbitMQ默认的vhost是/。 6 Exchange​ Exchange指交换器，是RabbitMQ最重要的组成部分，用来接收生产者发送的消息并将这些消息路由给RabbitMQ中的队列（Queue），3种常用的交换器： ​ a direct（发布与订阅） ​ b fanout（广播） ​ c topic（主题、规则匹配） 7 Queue​ Queue指消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或者多个队列中。消息将会一直保存在队列里面，直到消费者连接到该队列并将其取走。 8 Routing Key​ Routing Key指路由键，即RabbitMQ决定消息该投递到哪个队列的规则。队列通过路由键绑定到交换器。消息发送到RabbitMQ服务器时，消息将会拥有一个路由键，即使是空的，RabbitMQ也会将其和绑定使用的路由键进行匹配。 如果相匹配，消息将会投递到该队列。 如果不匹配，消息将会进入黑洞，被无尽的漆黑所吞噬。 9 Banding​ Banding指绑定，用于消息队列和交换器之间的关联。一个绑定(Banking Key)就是基于路由键(Routing Key)将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。 10 Connection​ Connection指RabbitMQ服务器和服务建立的TCP连接。 11 Channel​ Channel的中文叫信道，是TCP里面的虚拟连接。例如：电缆相当于TCP，信道是一条独立的光纤束，一条TCP连接上创建多少条信道是没有限制的。 ​ TCP一旦打开，就会创建AMQP信道。 ​ 无论是发布消息、接受消息、订阅队列，这些动作都是通过信道完成的。 五 如何安装RabbitMQ1 安装Erlang2 安装RabbitMQ3 激活 RabbitMQ’s Management Plugin4 创建用户、绑定角色安装RabbitMQ需要进行以上4步，安装配置成功后即可通过net start RabbitMQ启动，默认地址是localhost:15672。 六 RabbitMQ入门例子 - Spring boot0 pom.xml文件123456789101112131415161718192021222324252627282930&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 1 配置文件application.properties1234spring.rabbitmq.host=10.71.9.117spring.rabbitmq.port=5672spring.rabbitmq.username=rootspring.rabbitmq.password=root 2 定义队列123456789101112@Configurationpublic class SenderConfig &#123; @Bean public Queue queue()&#123; return new Queue("queue1"); &#125; @Bean public Queue queue2()&#123; return new Queue("queue2"); &#125;&#125; 3 定义消费者123456789101112@Component@RabbitListenerpublic class Reciver &#123; @RabbitListener(queues="queue1") public void process1(String msg)&#123; System.out.println("我是消费者1： "+msg); &#125; @RabbitListener(queues="queue2") public void process2(String msg)&#123; System.out.println("我是消费者2： "+msg); &#125;&#125; 4 定义生产者12345678910111213@Componentpublic class Provider &#123; @Autowired private AmqpTemplate rabbitTemplate; public void send()&#123; String msg1 = "我是queue1，我收到了！" + new Date(); this.rabbitTemplate.convertAndSend("queue1",msg1); String msg2 = "我是queue2，我收到了！" + new Date(); this.rabbitTemplate.convertAndSend("queue2",msg2); &#125;&#125; 5 Junit测试类12345678910111213@RunWith(SpringRunner.class)@SpringBootTest(classes=RabitmqApplication.class)public class RabbitmqSpringbootApplicationTests &#123; @Autowired private Provider sender; @Test public void send() throws InterruptedException &#123; while(true)&#123; Thread.sleep(1000); this.sender.send(); &#125; &#125;&#125; 运行结果： 七 交换器的实现方式1 采用Spring boot实现direct交换器当交换器指定为direct类型时，消息的路由键必须和队列所绑定的路由键完全匹配（一对一关系）才可识别。 业务场景：系统日志处理场景 ​ a、微服务产生的日志，交给日志服务器处理。 ​ b、日志处理服务器有2个服务，分别为INFO、ERROR ​ c、服务直接的通信采用direct 项目结构： a 子模块 - 消费者a1、pom.xml文件123456789101112131415161718192021222324252627282930&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; a2、application.properties文件1234567891011spring.rabbitmq.host=10.71.9.117spring.rabbitmq.port=5672spring.rabbitmq.username=rootspring.rabbitmq.password=rootmq.config.exchange=log.directmq.config.queue.info=infoQueuemq.config.queue.info.routing.key=log.info.keymq.config.queue.error=errorQueuemq.config.queue.error.routing.key=log.error.key a3 、定义消费者类123456789101112131415161718@Component//value是队列//exchange是交换器//key是路由键，连接队列和交换器@RabbitListener(bindings = @QueueBinding( value= @Queue(value="$&#123;mq.config.queue.error&#125;", autoDelete="true"), exchange=@Exchange(value="$&#123;mq.config.exchange&#125;",type=ExchangeTypes.DIRECT), key="$&#123;mq.config.queue.error.routing.key&#125;"))public class ErrorReciver &#123; @RabbitHandler public void process(String msg)&#123; System.out.println("接收到error日志 "+msg); &#125;&#125; 1234567891011121314151617@Component//value是队列//exchange是交换器//key是路由键，连接队列和交换器@RabbitListener(bindings = @QueueBinding( value= @Queue(value="$&#123;mq.config.queue.info&#125;", autoDelete="true"), exchange=@Exchange(value="$&#123;mq.config.exchange&#125;",type=ExchangeTypes.DIRECT), key="$&#123;mq.config.queue.info.routing.key&#125;"))public class InfoReciver &#123; @RabbitHandler public void process(String msg)&#123; System.out.println("接收到info日志 "+msg); &#125;&#125; b 子模块 - 生产者b1、pom.xml文件与消费者模块一致。 b2、application.properties文件1234567spring.rabbitmq.host=10.71.9.66spring.rabbitmq.port=5672spring.rabbitmq.username=rootspring.rabbitmq.password=root#exchangemq.config.exchange=log.direct b3、定义生产者类1234567891011121314@Componentpublic class SenderProvider &#123; @Autowired private AmqpTemplate rabbitTemplate; @Value("$&#123;mq.config.exchange&#125;") private String exchange; public void send(int i)&#123; String msg = "num: " + i; this.rabbitTemplate.convertAndSend(this.exchange,"log.info.routing.key",msg); System.out.println(msg); &#125;&#125; b4、Junit测试类12345678910111213@RunWith(SpringRunner.class)@SpringBootTest(classes=RabbitmqSpringbootApplication2.class)public class RabbitmqSpringbootApplicationTests &#123; @Autowired private SenderProvider sender; @Test public void send() throws InterruptedException &#123; for(int i=0 ; i&lt;200;i++)&#123; Thread.sleep(2000); this.sender.send(i); &#125; &#125;&#125; c 运行先启动消费者模块，对消息队列进行监听。 再运行生产者模块的Junit测试类。 2 采用Spring boot实现topic交换器topic交换器是按照特定规则的路由键进行匹配。 ​ 项目结构： a 子模块 - 消费者a1、pom.xml文件同上 a2、application.properties文件123456789spring.rabbitmq.host=10.71.9.117spring.rabbitmq.port=5672spring.rabbitmq.username=rootspring.rabbitmq.password=rootmq.config.exchange=log.topicmq.config.queue.info=log.infomq.config.queue.error=log.errormq.config.queue.logs=log.msg a3 、定义消费者类1234567891011121314151617@Component//value是队列//exchange是交换器//key是路由键，连接队列和交换器@RabbitListener(bindings = @QueueBinding( value= @Queue(value="$&#123;mq.config.queue.error&#125;", autoDelete="true"), exchange=@Exchange(value="$&#123;mq.config.exchange&#125;",type=ExchangeTypes.TOPIC), key="*.log.error"))public class ErrorReciver &#123; @RabbitHandler public void process(String msg)&#123; System.out.println("接收到error日志 "+msg); &#125;&#125; 1234567891011121314151617@Component//value是队列//exchange是交换器//key是路由键，连接队列和交换器@RabbitListener(bindings = @QueueBinding( value= @Queue(value="$&#123;mq.config.queue.info&#125;", autoDelete="true"), exchange=@Exchange(value="$&#123;mq.config.exchange&#125;",type=ExchangeTypes.TOPIC), key="*.log.info"))public class InfoReciver &#123; @RabbitHandler public void process(String msg)&#123; System.out.println("接收到info日志 "+msg); &#125;&#125; 1234567891011121314151617@Component//value是队列//exchange是交换器//key是路由键，连接队列和交换器@RabbitListener(bindings = @QueueBinding( value= @Queue(value="$&#123;mq.config.queue.logs&#125;", autoDelete="true"), exchange=@Exchange(value="$&#123;mq.config.exchange&#125;",type=ExchangeTypes.TOPIC), key="*.log.*"))public class LogsReciver &#123; @RabbitHandler public void process(String msg)&#123; System.out.println("接收到logs日志 "+msg); &#125;&#125; b 子模块 - 生产者b1、pom.xml文件同上。 b2、application.properties文件1234567spring.rabbitmq.host=10.71.9.117spring.rabbitmq.port=5672spring.rabbitmq.username=rootspring.rabbitmq.password=root#exchangemq.config.exchange=log.topic b3、定义生产者类123456789101112131415@Componentpublic class OrderSender &#123; @Autowired private AmqpTemplate rabbitTemplate; @Value("$&#123;mq.config.exchange&#125;") private String exchange; public void send()&#123; this.rabbitTemplate.convertAndSend(this.exchange,"order.log.debug","order.log.debug...............is coming!"); this.rabbitTemplate.convertAndSend(this.exchange,"order.log.info","order.log.info...............is coming!"); this.rabbitTemplate.convertAndSend(this.exchange,"order.log.warn","order.log.warn...............is coming!"); this.rabbitTemplate.convertAndSend(this.exchange,"order.log.error","order.log.error...............is coming!"); &#125;&#125; 123456789101112131415@Componentpublic class ProductSender &#123; @Autowired private AmqpTemplate rabbitTemplate; @Value("$&#123;mq.config.exchange&#125;") private String exchange; public void send()&#123; this.rabbitTemplate.convertAndSend(this.exchange,"product.log.debug","product.log.debug...............is coming!"); this.rabbitTemplate.convertAndSend(this.exchange,"product.log.info","product.log.info...............is coming!"); this.rabbitTemplate.convertAndSend(this.exchange,"product.log.warn","product.log.warn...............is coming!"); this.rabbitTemplate.convertAndSend(this.exchange,"product.log.error","product.log.error...............is coming!"); &#125;&#125; b4、Junit测试类1234567891011121314@RunWith(SpringRunner.class)@SpringBootTest(classes=RabbitmqSpringbootApplication2.class)public class RabbitmqSpringbootApplicationTests &#123; @Autowired private ProductSender productSender; @Autowired private OrderSender orderSender; @Test public void send() throws InterruptedException &#123; this.productSender.send(); this.orderSender.send(); &#125;&#125; c 运行先启动消费者模块，对消息队列进行监听。 再运行生产者模块的Junit测试类。 3 采用Spring boot实现fanout交换器fanout交换器为广播，即忽略所有路由键的规则，直接发送给所有的消费者。 具体代码基于上面两种情况，就不进行演示了。 八 消息确认ACK1 什么是消息确认ACK​ 如果在处理消息的过程中，消费者服务器、网络、出现了故障挂了，那可能这条正在处理的消息就没有完成，数据丢失，RabbitMQ支持消息确认 - ACK。 2 ACK的消息确认机制​ ACK机制是消费者端从RabbitMQ收到信息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从消息队列中删除。 ​ a、如果一个消费者在处理消息时挂掉（网络不稳定、服务器异常、网站故障等），那么就不会有ACK反馈，RabbitMQ会认为这个消息没有正常消费，会将此消息重新放入队列中。 ​ b、如果在集群情况下：RabbitMQ会立即将这个消息推送给这个在线的其他消费者。这种机制保证了再消费者服务器故障的时候，不会丢失任何消息和任务。 ​ c、消息永远不会从RabbitMQ服务器中删除，只有当消费者正确的发送ACK确认反馈，RabbitMQ收到确认之后，消息才会从RabbitMQ服务器中删除。 ​ d、消息的ACK确认脊椎默认是打开的。 3 ACK机制的开发注意事项如果忘记了ACK，那么后果会很严重。当Consumer退出时，Message会一直重新发布。然后RabbitMQ会占用越来越多的内存，由于RabbitMQ会长时间运行，因此这个‘内存泄露’是致命的。 ​ ​]]></content>
      <categories>
        <category>计算机</category>
        <category>中间件</category>
        <category>消息队列</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>中间件</tag>
        <tag>消息队列</tag>
        <tag>Queue</tag>
        <tag>生产-消费者模型</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[干高等数学 - 映射与函数（第一章第一节）]]></title>
    <url>%2F2018%2F11%2F30%2F%E6%98%A0%E5%B0%84%E4%B8%8E%E5%87%BD%E6%95%B0%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%89%2F</url>
    <content type="text"><![CDATA[映射与函数一 映射1 概念1.1 映射​ 设X、Y是两个非空集合，如果存在一个法则f，使得对X中每个元素x，按法则f，在Y中有唯一确定的元素y与之对应，那么称f为从X到Y的映射，记作： f:X→Y 1.2 像​ 其中y称为元素x（在映射f下）的像，并记作f(x)，即： y=f(x)1.3 原像​ 元素x称为元素y（在映射f下）的一个原像。 1.4 定义域​ 集合X称为映射f的定义域，记作： D_f=X1.5 值域​ X中所有的元素的像组成的集合称为映射f的值域，记作： R_f或f(X)所以映射可以表示为： R_f=f(X)=\{f(x)|x∈X\}1.6 满射​ 设 $f$ 是从集合 $X$ 到集合 $Y$ 的映射，若$R_f=Y$，即 $Y$ 中任一元素 $y$ 都是 $X$ 中某元素的像，则称 $f$ 为 $X$ 到 $Y$ 上的映射或满射。 1.7 单射​ 若对 $X$ 中任意两个不同元素 $x_1≠x_2$ ，它们的像 $f(x_1)≠f(x_2)$ ，则称 $f$ 为 $X$ 到 $Y$ 的单射。 1.8 双射​ 若映射 $f$ 既是单射，又是满射时，称 $f$ 为双射（或一一映射）。 2 构成映射的三要素​ 集合$X$，即定义域$D_f=X$ ; ​ 集合$Y$，即值域的范围：$R_f⊂Y$； ​ 对应法则 $f$ , 使对每个 $x∈X$，有唯一确定的 $y=f(x)$ 与之对应。 3 逆映射​ 设f是X到Y的单射，则由定义，对每个y∈R_f，有唯一的x∈X，适合f(x)=y。 于是我们可以定义一个从R_f到X的新映射g，即 R_f→X对每个y∈R_f，规定g(y)=x，这x满足f(x)=y。这个映射g称为f的逆映射，记作 $f^{-1}$，其定义域 $D_{f^-1}=R_f$，值域 $R_{f^-1}=X$。 4 复合映射​ 设有两个映射， ​ $g:X→Y_1$ ， ​ f:Y_2→Z ​ 其中Y_1⊂Y_2，则由映射 g 和 f 可以定义出一个从X到Z的对应法则，它将每个 x∈X 映射成 f[g(x)]∈Z。显然，这个对应法则确定了一个从 X 到 Z 的映射，这个映射称为映射 g 和 f 构成的复合映射，记作f。g，即： f。g:X→Z，(f。g)(x)=f[g(x)],x∈X由复合映射的定义可知，映射g和f构成复合映射的条件是： $g$ 的值域 $R_g$ 必须包含在 $f$ 的定义域内，即 $R_g⊂D_f$， 否则不能构成复合映射。 二 函数1 函数的有界性如果存在正数 $M$，使得对任意 $x∈X$，都有 $|f(x)|≤M$，则称函数 $f(x)$ 在 $X$上有界。如果 $M$ 不存在，则证明 $f(x)$ 在 $X$ 无界。 2 函数的单调性设函数 $f(x)$ 的定义域为D，区间 $I⊂D$ ，如果对于区间I内任意两点$x_1$，$x_2$，当$x_1$&lt;$x_2$时，恒有： f(x_1)]]></content>
      <categories>
        <category>高等数学</category>
        <category>第一章</category>
        <category>第一节</category>
        <category>映射与函数</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>映射</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【干了这杯源码】集合框架 List之Stack（五）]]></title>
    <url>%2F2018%2F11%2F24%2F%E3%80%90%E5%B9%B2%E4%BA%86%E8%BF%99%E6%9D%AF%E6%BA%90%E7%A0%81%E3%80%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-List%E4%B9%8BStack%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Stack一 概述​ Stack英文意思为一大堆，Java JDK中的Stack类用于模拟数据结构中的栈。​ 什么是栈结构，用最简单的比喻，栈结构就如同桌子上整齐堆叠的一些书本，当你存放的时候，必须一本一本的往上放(入栈)，当你取书的时候必须从最上面一本一本的往下拿(出栈)。​ 所以，栈结构的特点是先进者后出，后进者先出，就是所谓的FILO( First In Last Out)。​ Stack 继承于Vector类，所以Stack是一个线程安全的基于数组实现的栈结构。​ 提示：JDK中的Deque接口提供了一个更加优秀和实用的LIFO栈结构，用来替代Stack类: 1Deque stack = new ArrayDeque(); Stack继承图 二 Stack的属性​ 由于Stack继承Vector类，所以Stack的属性就是Vector的属性，无额外属性。 1 elementData12//该属性为Object类型的空数组,是Stack的底层存储数组protected Object[] elementData; 2 elementCount12//Stack的实际元素个数(等同于其他集合的size)protected int elementCount; 3 capacityIncrement123//capacityIncrement为Stack每次自动增长的大小，//若capacityIncrement小于等于0，则按默认自动扩充为原来的1倍protected int capacityIncrement; 4 modCount1234567//modCount属性为list被结构性修改(structurally modified)的总次数，//结构性修改为任意对size进行修改的操作，如add()、remove()等。//modCount属性继承于父抽象类AbstractList。//modCount属性的主要用于确保iterator遍历的准确性，防止多个线程对该list进行操作，//如果在iterator遍历过程中，另一个线程对该list进行了结构性修改(即modcount改变)，//java将会抛出ConcurrentModificationException异常，也就是fail-fast机制.protected transient int modCount = 0; 三 Stack构造函数12//Stack就只有一个默认构造函数，Stack不支持Vector的各种制定参数的构造方法。public Stack() &#123;&#125; 四 Stack方法之 增1234567//入栈方法,把元素添加到Stack最后一个位置public E push(E item) &#123; //实际上调用了父类Vector的addElement方法, //addElement()和push()方法本质上没有任何差别。 addElement(item); return item; &#125; 1234567//父类的addElement方法如下public synchronized void addElement(E obj) &#123; modCount++; //判断是否需要自动扩充数组 ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj;&#125; 五 Stack方法之 查1 peek()方法12345678 //该方法查询出Stack的最后一个元素,但是不删除该元素public synchronized E peek() &#123; int len = size(); if (len == 0) //如果Stack为空则抛出EmptyStackException异常 throw new EmptyStackException(); return elementAt(len - 1);&#125; 2 search(Object o)方法12345678public synchronized int search(Object o) &#123; //lastIndexOf()方法下面会说. int i = lastIndexOf(o); if (i &gt;= 0) &#123; return size() - i; &#125; return -1;&#125; ​ 父类的lastIndexOf()方法 123456789101112131415161718//该方法返回Object o 在Stack中最后一个出现的位置public synchronized int lastIndexOf(Object o, int index) &#123;//判断是否越界 if (index &gt;= elementCount) throw new IndexOutOfBoundsException(index + " &gt;= "+ elementCount); //分为不为空两种情况 if (o == null) &#123; for (int i = index; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = index; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; 六 Stack方法之 改​ Stack没有提供专属的修改方法，修改方法继承父类Vector。 七 Stack方法之 删123456789public synchronized E pop() &#123; E obj; int len = size(); //通过peek()方法返回Stack最后一个元素 obj = peek(); //移除Stack数组的最后一个元素 removeElementAt(len - 1); return obj;&#125; 八 优点​ Stack提供了出栈（pop）、入栈（push）等方法来实现栈数据结构，并且Stack是全线程安全的，所有方法都上了同步锁。 九 缺点​ 1、Stack由于继承了Vector类，导致其所有方法都加了同步锁，使得运行效率低下。 ​ 2、Stack和Vector一样作为远古时期的JDK类，属于即将被时代所淘汰的产物，官方并不建议使用这两个类。 ​ 若果你需要在多线程下使用Vector类，请使用以下替代品： ​ a、java.util.concurrent.CopyOnWriteArrayList ​ b、Collections.synchronizedList ​ 若果你要使用Stack类，请使用以下替代品： ​ 非多线程： ​ a、linkedList ​ 多线程： ​ b、java.util.concurrent.ConcurrentLinkedDeque ​ c、java.util.concurrent.ConcurrentLinkedQueue ​ d、ArrayDeque 十 总结​ Stack是基于数组实现的线程安全的栈结构，但是由于时代的演化，不建议大家使用该类进行业务开发，抛弃它吧！ ​​​]]></content>
      <categories>
        <category>计算机</category>
        <category>Java</category>
        <category>干了这杯源码</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合框架</tag>
        <tag>源码</tag>
        <tag>List</tag>
        <tag>Stack</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【干了这杯源码】集合框架 List之Vector（四）]]></title>
    <url>%2F2018%2F11%2F19%2F%E3%80%90%E5%B9%B2%E4%BA%86%E8%BF%99%E6%9D%AF%E6%BA%90%E7%A0%81%E3%80%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-List%E4%B9%8BVector%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Vector一 概述 ​ Vector来自于远古的JDK1.0，属于上古时期的类，因为其所有方法都上了同步锁，所以性能会比ArrayList低很多。​ Vector和ArrayList一样实现了可自动扩充的数组，都可根据下标直接访问元素，另外Vector可以根据需求改变自动增长的策略，默认每次增为原来的一倍。​ Vector是线程安全的，扫一眼源码你会发现，Vector很多方法都加了synchronized关键字，确保了线程的安全性。数据结构：数组 二 Vector的属性1 elementData12//该属性为Object类型的空数组，是Vector的底层存储数组protected Object[] elementData; 2 elementCount12//Vector的实际元素个数(等同于其他集合的size)protected int elementCount; 3 capacityIncrement12//capacityIncrement为Vector每次自动增长的大小，若capacityIncrement小于等于0，则按默认自动扩充为原来的1倍。protected int capacityIncrement; 4 modCount12//modCount属性为list被结构性修改的总次数protected transient int modCount = 0; 结构性修改(structurally modified)为改变size大小的操作，如add()、remove()等。modCount属性继承于父抽象类AbstractList。modCount属性的主要用于确保iterator遍历的准确性，防止多个线程对该list进行操作，如果在iterator遍历过程中，另一个线程对该list进行了结构性修改(即modcount改变)，java将会抛出ConcurrentModificationException异常,也就是fail-fast机制。 三 Vector构造函数1 无参构造函数1234//若为无参构造函数则自动调用Vector(int initialCapacity),其中initialCapacity==10public Vector() &#123; this(10);&#125; 2 initialCapacity为参数的构造函数1234//若调用此构造方法，则自动调用Vector(int initialCapacity, int capacityIncrement)方法，其中capacityIncrement=0public Vector(int initialCapacity) &#123; this(initialCapacity, 0);&#125; 3 initialCapacity和capacityIncrement为参数的构造函数12345678910public Vector(int initialCapacity, int capacityIncrement) &#123; super(); //initialCapacity不能小于0 if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); //赋值给elementData this.elementData = new Object[initialCapacity]; //赋值给capacityIncrement this.capacityIncrement = capacityIncrement;&#125; 四 Vector方法 — 查询12345//查询元素下标public int indexOf(Object o) &#123; //调用indexOf(Object o, int index) 方法，index参数为0 return indexOf(o, 0);&#125; 1234567891011121314//查询元素o下标，并从index位置开始查找public synchronized int indexOf(Object o, int index) &#123; //分o为null和不为null两种情况 if (o == null) &#123; for (int i = index ; i &lt; elementCount ; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = index ; i &lt; elementCount ; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; 五 Vector方法 — 增Vector新增有两个方法，一个是add，一个是addElement，他们两个的唯一区别就是返回值的不同。 1 add(E e)方法12345678//add()方法返回布尔值public synchronized boolean add(E e) &#123; modCount++; //检查是否需要扩容 ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125; 2 addElement(E obj)方法1234567//addElement()方法没有返回值public synchronized void addElement(E obj) &#123; modCount++; //检查是否需要扩容 ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj;&#125; 六 Vector方法 — 改12345678910//将Vector下标为index的元素替换成elementpublic synchronized E set(int index, E element) &#123; //判断下标是否合法 if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); //记录即将被替换的旧元素 E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 七 Vector方法 — 删1 删除指定元素 removeElement（Object obj）1234567891011public synchronized boolean removeElement(Object obj) &#123; modCount++; //找到要删除元素obj的下标 int i = indexOf(obj); //如果存在，则调用removeElementAt()方法删除该元素 if (i &gt;= 0) &#123; removeElementAt(i); return true; &#125; return false;&#125; 2 删除指定下标的元素 removeElementAt(int index)123456789101112131415161718192021public synchronized void removeElementAt(int index) &#123; modCount++; //判断下标是否合法 if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + " &gt;= " + elementCount); &#125; //判断下标是否小于0 else if (index &lt; 0) &#123; throw new ArrayIndexOutOfBoundsException(index); &#125; //j为要删除的元素的下标位置 int j = elementCount - index - 1; //j&gt;0既删除的元素不是最后一个 if (j &gt; 0) &#123; //将数组从要删除的元素位置开始往前移，覆盖掉要删除的元素 System.arraycopy(elementData, index + 1, elementData, index, j); &#125; elementCount--; //让数组最后一个元素指向null，gc自动回收机制开始工作 elementData[elementCount] = null; /* to let gc do its work */ &#125; 八 Vector优点 1. 相当于线程安全的ArrayList 2. 可自动扩容 九 Vector缺点 因为线程太安全，所以性能极差 ​ 总结​ Vector这个类目前已经很少人使用，慢慢将会被历史抛弃，大家有兴趣就了解一下。目前如果有业务需要用到线程安全的可扩充数组，首选还是选用同步过后的ArrayList，同步的方法有Collections.synchronizedList和CopyOnWriteArrayList两种。]]></content>
      <categories>
        <category>计算机</category>
        <category>Java</category>
        <category>干了这杯源码</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合框架</tag>
        <tag>源码</tag>
        <tag>List</tag>
        <tag>Vector</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【干了这杯源码】集合框架 List之LinkedList（三）]]></title>
    <url>%2F2018%2F11%2F03%2F%E3%80%90%E5%B9%B2%E4%BA%86%E8%BF%99%E6%9D%AF%E6%BA%90%E7%A0%81%E3%80%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-List%E4%B9%8BLinkedLIst%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LinkedList概述 LinkedList 继承List接口，继承了List所有的方法。 LinkedList 允许存入任意类型的元素（包括null）。 LinkedList 继承了Deque接口（双端队列），该接口提供了一些方法，让我们可以获取、删除、插入队头或者队尾的元素。 LinkedList 是线程非安全的，你可以从外部自己加同步锁，也可以使用Collections.synchronizeList()方法对LinkedList进行包装。用法Collections.synchronizeList(new LinkedList)。 数据结构jdk1.6之前LinkedList采用一个固定头结点的双向循环链表作为结构（头结点的元素为null）。 12//头结点的初始化private transient Entry&lt;E&gt; header = new Entry&lt;E&gt;(null,null,null); jdk1.6之后LinkedList进行了改版，由原来带头结点的==循环双向链表==改为不带头结点的==双向链表==，分别采用first和last两个指针指向链表首尾结点。 1234//first指针初始化，默认等于null，既指向nulltransient Node&lt;E&gt; first;//last指针初始化,默认等于null，既指向nulltransient Node&lt;E&gt; last; LinkedList的属性0 Node1234567891011121314//Node代表着LinkedList的每一个结点，是LinkedList的静态内部类。//jdk1.6之前，结点名称叫Entry//jdk1.6之后，结点名称叫Nodeprivate static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 1 size12//LinkedList的实际元素个数private int size; 2 first12345//指向首节点的指针//满足以下恒等式：//(first == null &amp;&amp; last == null) ||// (first.prev == null &amp;&amp; first.item != null)transient Node&lt;E&gt; first; 3 last12345//指向尾结点的指针//满足以下恒等式：//(first == null &amp;&amp; last == null) ||// (last.next == null &amp;&amp; last.item != null)transient Node&lt;E&gt; last; 4 modCount12//modCount属性为list被结构性修改的总次数protected transient int modCount = 0; 结构性修改(structurally modified)为改变size大小的操作，如add()、remove()等。modCount属性继承于父抽象类AbstractList。modCount属性的主要用于确保iterator遍历的准确性，防止多个线程对该list进行操作，如果在iterator遍历过程中，另一个线程对该list进行了结构性修改(即modcount改变)，java将会抛出ConcurrentModificationException异常,也就是fail-fast机制。 LinkedList构造函数1 无参构造函数123//无参构造函数，因为first和last指针初始都为null，//所以该方法内没必要指定first和last的值。 public LinkedList() &#123;&#125; 2 Collection为参数的构造函数1234public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; addAll(Collection c)方法内部调用了addAll(int index, Collection c)方法 123public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//该方法为在LinkedList的指定位置插入Collectionpublic boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; //检查插入的位置是否合法 checkPositionIndex(index); //把Collection转化为Object数组 Object[] a = c.toArray(); //numNew为Collection的元素个数 int numNew = a.length; //若没有元素则返回false if (numNew == 0) return false; //pred代表下标为index结点的前一个结点 //succ代表下标为index的结点 Node&lt;E&gt; pred, succ; //如果插入的位置等于LinkedList本身的大小， //既在LinkedList最后一个位置插入（若没有元素，则在第一位） if (index == size) &#123; //因为在LinkedList最后插入，所以插入下标index没有元素 succ = null; //pred最后一个结点 pred = last; &#125; else &#123; //在LinkedList中间插入Collection //succ等于下标结点 succ = node(index); //pred等于下标结点的前一个 pred = succ.prev; &#125; //插入元素，遍历数组，让链表指向依次改变 for (Object o : a) &#123; @SuppressWarnings("unchecked") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; //插入完之后，判断是否在尾部插入 if (succ == null) &#123; //尾部插入，last指针指向pred即可 last = pred; &#125; else &#123; //中部插入，需要连接被切开的后端部分 //让pred的后继指针指向被切开的下标结点 pred.next = succ; //让被切开的下标结点succ前驱指针指向pred succ.prev = pred; &#125; size += numNew; modCount++; return true;&#125; LinkedList方法 — 查询123456public E get(int index) &#123; //检查下标是否合法 checkElementIndex(index); //调用node(index)方法获取以index下标的结点 return node(index).item;&#125; 1234567891011121314151617//获取idnex下标结点Node&lt;E&gt; node(int index) &#123; // 判断index是否小于size的一半（此处采用右移运算符，提高计算效率） // 若index小于size的一半，则从链表第一个开始遍历 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; //若index大于size的一半，则从链表尾部往前遍历 Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; LinkedList方法 — 增我们在构造函数的时候已经介绍了addAll()方法，相对而言add()就显得简单许多。 12345//LinkedList末尾插入元素public boolean add(E e) &#123; linkLast(e); return true;&#125; 12345678//LinkedList中部插入元素public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125; ​ 上面两个插入方法都调用了linkLast(element) 12345678910111213141516void linkLast(E e) &#123; //定义l结点为LinkedList的最后一个元素 final Node&lt;E&gt; l = last; //定义newNode结点的前驱结点为l，元素为e，后继为null final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //让last指针指向newNode结点 last = newNode; if (l == null) //l结点为null代表LinkedList没有元素 first = newNode; else //反之则l结点的后继指针指向newNode l.next = newNode; size++; modCount++;&#125; LinkedList方法 — 改12345678//直接替换结点的元素，不需要改变指针指向public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125; LinkedList方法 — 删12345public E remove(int index) &#123; checkElementIndex(index); //调用unlink方法 return unlink(node(index));&#125; 123456789101112131415161718192021222324252627//删除方法也容易理解//1、将被删除结点的前驱结点的后继指针指向删除结点的后继结点//2、将被删除结点的后继结点的前驱指针指向删除结点的前驱结点E unlink(Node&lt;E&gt; x) &#123; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; LinkedList优点​ 1.插入和删除元素效率高，不需要像ArrayList一样移动数组。​ 2.可以被当做栈和队列使用 LinkedList缺点​ 1.根据下标遍历元素效率低。​ 2.根据下标访问元素效率低。​ 3.根据下标修改元素效率低。​ 4.结点占有的空间比ArrayList多，因为除了元素本身，保存了前驱后继指针。 总结​ LinkedList是基于链表实现的双向链表（循环），因此LinkedList具有链表所具有的优缺点，既插入、删除元素高效，而指定下标查询和修改元素效率低下。​ LinkedList是线程非安全的，只能在单线程的环境下使用。可以采用该方法解决Collections.synchronizedList。​ LinkedList的优势在于插入和删除元素只需移动指针，固需要频繁进行插入和删除操作时，LinkedList应当首选。]]></content>
      <categories>
        <category>计算机</category>
        <category>Java</category>
        <category>干了这杯源码</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合框架</tag>
        <tag>源码</tag>
        <tag>List</tag>
        <tag>LinkedList</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【干了这杯源码】集合框架 List之ArrayList（二）]]></title>
    <url>%2F2018%2F11%2F02%2F%E3%80%90%E5%B9%B2%E4%BA%86%E8%BF%99%E6%9D%AF%E6%BA%90%E7%A0%81%E3%80%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-List%E4%B9%8BArrayList%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ArrayList概述 ​ ArrayList的底层数据结构为数组，实现了List接口，允许传入所有类型的元素(包括null)。​ ArrayList内部提供了方法，对数组的大小进行自动扩充。​ ArrayList进行add方法时，时间复杂度为O(n)，其他操作方法的时间复杂度为O(1)(粗略地讲)。​ 每一个ArrayList实例都包含一个capacity(容量)，这个capacity用来记录数组的size(实际元素个数)，并且满足条件capacity≥size。当一个元素被添加进ArrayList时，size加1，capacity会判断是否进行扩充。​ ArrayList是线程非安全的，如果多个线程同时对ArrayList进行结构性操作（增删），一定要在外部加上同步锁。​ ArrayList除了是线性非安全之外，粗略的等价于Vector类。 数据结构 : 数组 线程安全 : 非线程安全​ 解决办法 Collections.synchronizedList &amp; CopyOnWriteArrayList 两种​ CopyOnWriteArrayList 写操作性能较差，而读操作性能较好​ Collections.synchronizedList 写的操作好，因为加了锁的原因，读较差 ArrayList的属性1 DEFAULT_CAPACITY12//该属性为默认的初始容量private static final int DEFAULT_CAPACITY = 10; 2 EMPTY_ELEMENTDATA12//该属性为Object类型的空数组private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; 3 DEFAULTCAPACITY_EMPTY_ELEMENTDATA12//该属性为Object类型的空数组,用于未指定初始大小的实例private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; 你可能会问,为什么有了EMPTY_ELEMENTDATA，之后还要单独再弄一个DEFAULTCAPACITY_EMPTY_ELEMENTDATA?这么做的作用是区分出elementData是从什么地方初始化的，是无参构造函数还是有参构造函数。 4 elementData12//该属性为缓存数组transient Object[] elementData; ArrayList新增元素时，新增的元素会保存到该缓存数组中，该缓存数组的大小为capacity，当使用无参构造函数后（大家可以看看下面无参构造的具体代码），既elementDate==DEFAULTCAPACITY_EMPTY_ELEMENTDATA，当ArrayList首次使用add方法时，会扩充成为elementData的大小会自动变为DEFAULT_CAPACITY。 5 size12//ArrayList的实际元素个数private int size; 6 modCount12//modCount属性为list被结构性修改的总次数protected transient int modCount = 0; 结构性修改(structurally modified)为改变size大小的操作，如add()、remove()等。modCount属性继承于父抽象类AbstractList。modCount属性的主要用于确保iterator遍历的准确性，防止多个线程对该list进行操作，如果在iterator遍历过程中，另一个线程对该list进行了结构性修改(即modcount改变)，java将会抛出ConcurrentModificationException异常,也就是fail-fast机制。 ArrayList构造函数1 无参构造函数123public ArrayList() &#123; this.elementData = EFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 当调用此构造函数时，缓存数组(elementData)将会被赋值为DEFAULTCAPACITY_EMPTY_ELEMENTDATA，并且初始化长度为DEFAULT_CAPACITY 2 initialCapacity参数构造函数123456789public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: " + initialCapacity); &#125; &#125; 3 Collection为参数的构造函数1234567891011public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; 细心的你可能会注意到这段注释 1// c.toArray might not return Object[] (see 6260652) 意思是c.toArray的返回值可能不会 ArrayList方法1 查询1234public E get(int index) &#123; rangeCheck(index);//检查下标是否合法 return elementData(index);//直接返回数组的下标&#125; ​ 该方法实现较为简单,只需检测传入的index值是否合法 2 增1234567891011121314151617//为list添加特定元素到特定位置,并且插入时自动右移数组public void add(int index, E element) &#123; //检测传入的index是否在正确范围之内 rangeCheckForAdd(index); //判断size+1和elementData.length谁大，如果size+1比elementData.length大， //则调用grow(int minCapacity)方法，grow方法若符合条件，则elementDate自动扩充为原来的1.5倍， //有兴趣的同学可以自己去查阅grow的源码。 ensureCapacityInternal(size + 1); //该方法实现了数组后移的操作，System.arraycopy()方法被native修饰符修饰， //底层是调用C语言的memmove()方法， //特别是对性能要求苛刻的开发，更适合用此方法! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; 3 改1234567//特换特定位置的元素，同样检测index是否合法，返回被替换的元素public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 4 删​ 根据下标删除元素，返回被删除的元素​ 12345678910111213141516public E remove(int index) &#123; //检测传入的index是否在正确范围之内 rangeCheck(index); //总操作数+1 modCount++; E oldValue = elementData(index); //记录数组中要移动的元素个数 int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // clear to let GC do its work // size-1，并且让数组最后一位为空 elementData[--size] = null; return oldValue;&#125; ArrayList优点​ 1.根据下标遍历元素效率高。​ 2.根据下标访问元素效率高。​ 3.在数组的基础上封装了各种对元素操作的方法。​ 4.当数组容量不足时,ArrayList会对数组自动扩容0.5倍。 ArrayList缺点​ 1.由于数组的原因,插入和删除元素效率低。​ 2.根据元素查找元素效率低。 总结​ ArrayList是基于数组实现的动态数组，其容量会在每次执行add操作时会在内部进行ensureCapacity()判断，若符合条件则自动扩容0.5倍。​ ArrayList是线程非安全的，只能在单线程的环境下使用。解决办法有Collections.synchronizedList和CopyOnWriteArrayList两种，分别有各自的特点。​ ArrayList的优势在于通过下标快速访问元素效率高，倘若需要频繁进行插入和删除操作时，ArrayList不是首选。]]></content>
      <categories>
        <category>计算机</category>
        <category>Java</category>
        <category>干了这杯源码</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合框架</tag>
        <tag>源码</tag>
        <tag>List</tag>
        <tag>ArrayList</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【干了这杯源码】集合框架 Collection接口介绍（一）]]></title>
    <url>%2F2018%2F10%2F08%2F%E3%80%90%E5%B9%B2%E4%BA%86%E8%BF%99%E6%9D%AF%E6%BA%90%E7%A0%81%E3%80%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-Collection%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Collection接口概述​ Collection是集合框架的根接口(root interface)，一个Collection代表了一组元素的集合，一部分Collection允许元素重复、有序排列，一部分则相反，在JDK中没有提供任何直接实现Collection的实现类，但是提供了很多特异性的子接口，例如Set、List和Queue，这些子接口将会极大程度地覆盖日常开发使用的情景。 所有实现Collection接口的实现类都包含了两个构造器: 1.无参构造器 2.参数为Collection的构造器(该构造器将会构造出与参数Collection元素相同的集合) 值得注意的是，此处并无方法强制去规定实现类要包含这两个构造器(因为接口不能定义构造器)，但是所有的Collection实现类都遵循了这项规定。 ​ 一些Collection的实现类对元素进行了限制。比如,有些Collection实现类禁止null元素，有些则限制了元素的类型。一旦企图去添加无资格(ineligible)的元素将会抛出非检查型异常(Unchecked Exception) ,企图去查询无资格(ineligible)的元素也有有可能会抛出异常，或者直接return false。 ​ 另外，集合是否线程安全取决于每个集合自身的同步策略。当这个集合缺乏一个强有力的线程保护时。 Collection全家桶 List接口​ 是一个有序、可重复、可为null的集合接口 List接口常用实现类为三个 ： 1、ArrayListList接口中最实用的实现类，底层由数组构成 2、LinkedListLinkedList的数据结构是双向链表。它也可以被当作堆栈、队列或双端队列进行操作。 3、Vector通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。 3.1、StackStack类表示后进先出（LIFO）的对象堆栈。 Set接口不允许元素重复，集合元素唯一(元素可以为null)，无序。 Set接口常用实现类为 1、HashSetHashSet使用哈希表（hash table）实现的，其中的元素是无序的 1.1、LinkedHashSetLinkedHashSet介于HashSet和TreeSet之间。它基于一个由链表实现的哈希表，保留了元素插入顺序。 2、TreeSetTreeSet使用树形结构（红黑树）实现的，TreeSet中的元素是可排序的。 3、EnumSetEnumSet是一个专为枚举类设计的集合类，EnumSet中所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式或隐式地指定。EnumSet的集合元素也是有序的，EnumSet以枚举值在Enum类的定义顺序来决定集合元素的顺序。 Queue接口queue接口用于模拟队列数据结构,采用”先进先出”的方式 Deque数据结构为双端队列 Queue接口常用实现类为1.PriorityQueuePriorityQueue为优先队列，它的逻辑结构是一课完全二叉树（堆），存储结构其实是一个数组，具有堆的特点，可以实现小顶堆和大顶堆 2.ArrayQueueArrayQueue为基于数组实现的队列 3.LinkedListLinkedList为基于链表实现的队列 总结以上是Collection接口常用子接口及其常用实现类的介绍，有一点值得注意的是，Map接口虽然被理论上归入集合框架，但是于Collection并无交集，独立出来。]]></content>
      <categories>
        <category>计算机</category>
        <category>Java</category>
        <category>干了这杯源码</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合框架</tag>
        <tag>源码</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【干了这杯源码】集合框架 数据结构（零）]]></title>
    <url>%2F2018%2F10%2F08%2F%E3%80%90%E5%B9%B2%E6%BA%90%E7%A0%81%E3%80%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%20%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E9%9B%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[概述​ 本专题将会给大家来带Java最实用的东西—-集合框架，并将会直接从源码入手，直接干源码！由于集合框架的底层离不开数据结构，想搞清楚List、Set、Map等的底层实现，必须先从数据结构开始讲起。所以开山第一篇，将会给大家介绍计算机的数据结构。 ​ 数据结构可以说是计算机入门必修课程，同时也是特别烧脑的纯理论知识。所以本篇将会尽量避开让人看不懂的奇奇怪怪的东西，以生动形象的图文并茂带你窥探神秘的数据结构。 什么是数据结构？ 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。 —《百度百科》 科学家和人类应该不是一个物种，他们定义的名词读起来都比较拗口、而且十分不好理解。 什么是数据结构，举个通俗易懂的例子： 比如在现实世界里，你、我、其他所有人都属于数据元素，我们每个人之间都存在着错综复杂的关系。就好比：你是大名鼎鼎的太子、拥有至高无上的权利和无尽的财富，而我是个小小的皇上，我们之间就所形成的关系就是数据结构。 数据结构分为三个部分 可能有人会有疑问，数据结构和算法有什么关系呢？其实，数据结构和算法是相辅相成的，在计算机领域里面，谁也离不开谁。倘若失去了数据结构，算法会显得无比空洞；抛开算法，数据结构将会变成摆设！本篇将主要介绍逻辑结构和物理结构，至于算法会在后续章节，具体问题详细分析。 一、逻辑结构逻辑结构简单来说是指数据元素之间的前后件关系，主要包括4类。 1.集合结构数据结构之间除了“属于同集合” 的关系外，别无其他关系。 上图所有人（数据元素）同属于一个皇宫（集合） 2.线性结构数据结构之间的元素是一对一的关系。 上图为一对一的线性结构，例子：数组、链表、栈和队列 3.树形结构数据结构之间的元素存在一对多的相互关系 上图所示为一对多的树形结构，举例：二叉树、红黑树 4.图形结构数据结构中的元素存在多对多的相互关系。 如上图所示，虽关系略微复杂，却反映出图形结构多对多的关系。 ​ 二、物理结构指数据的逻辑结构在计算机存储空间的存放形式。 （提醒：该部分为本篇的重点，也是后面篇章讲解集合框架所依赖的东西。本篇将由浅入深、循序渐进，后面在具体讲到某 一个具体集合类时，会结合具体的方法来解读对应的储存结构） 通常来说数据的物理结构分为四类： 1.顺序存储结构把逻辑上相邻的结点存储在物理位置上相邻的存储单元中，结点之间的逻辑关系由存储单元的邻接关系来体现。 好比↑：国王和士兵们一起去菜市场排队买苹果，此时他们排成一对，紧紧的站在一起，就形成了一个顺序存储结构。 优点：查询元素效率高 因为顺序存储结构在逻辑和物理都是相邻的排序，所以找第几个士兵，直接就可以定位到目标。 缺点：插入和删除元素效率低(随机位置) 由于此结构的特性，每次插入和删除都要使整一个存储结构前移或者后移，相当影响性能。 举个例子↓，假设你是大名鼎鼎的太子，拥有至高无上的权利和地位，你路过菜市场，看到大家都在排队买苹果，你也跟风要买。你不仅要买还要插队，大家没办法只能默默的往后退一步，让出第一的位置给你，这过程体现了顺序存储结构插入的效率低下。 删除元素也同理↓，国王在队伍后面目睹了这一切，下令处死太子，太子就被拉出去枪毙了，大家又依次往前一步。 2.链式存储结构在计算机中用一组任意的存储单元存储线性表的数据元素，结点间的逻辑关系是由附加的指针字段表示。简单来讲，逻辑上相邻的数据元素，在物理结构上可以随意存放，不要求物理结构相邻，同时每个逻辑相连的元素手里都拿着一把指针指向下一个元素。 就比如↑：国王和太子们乘坐搭巴士，上了巴士之后不一定要找两个相邻的位置，有位置就可以坐。国王只需记住第一个太子的位置，每一个太子都只记着下一个太子的位置，就形成了一个链式储存结构。 优点：插入和删除元素效率高(随机位置) 如上图所示↓，如果此时皇后也上了巴士，且皇后要坐在国王的下一个位 置，那么只需要将国王的指针指向皇后，皇后的指针指向A太子，就插入成功！ 缺点：查找元素效率低由于链式存储结构的特性，如果你要找到D太子，你必须先找到C太子，要找到C太子必须先找到B太子，以此类推，你要先找到国王，再从国王指引的方向一个一个找过去。 3.索引存储结构索引存储结构是用结点的索引号来确定结点存储地址,其优点是检索速度快,缺点是增加了附加的索引表,会占用较多的存储空间。 索引存储结构由于其除了数据元素本身之外，还额外创建索引表，索引表的每个节点包含了索引键值和指针，如下图所示↓（以二叉树为索引表） 国王记性不好，记不住每一个人的地址，所以额外创建了一个索引表，方便快速定位。比如今晚想找尼姑一起研究数据结构，不用一个一个房间去敲门，只需要找到索引表的尼姑，就可以找到尼姑的具体地址。 优点：数据检索的速度快 缺点： 创建索引需要占用物理空间和消耗时间 对数据元素进行维护的同时，索引表也需要进行维护，影响性能 4.散列存储结构定义：实质上就是通过节点的关键字，再通过某一特定的计算，算出该关键字对应的物理地址。 散列（哈希）表：用散列法存储的线性结构被称为散列表或者哈希表，使用的函数f(k)被称为散列函数或者哈希函数，f(k)的值被称为散列地址或者哈希地址。通常情况下，散列表的存储空间是一个一维数组，而其哈希地址为数组的下标。 举个栗子：国王希望将皇宫内所有女性，按照某些指数，进行计算、分类如下图↓ 将每个节点元素通过散列函数f(k)计算出地址，并存放到相应的位置，如此就形成了哈希表。 比如查询”尼姑”数据是否存在时，只需要根据”尼姑”的”三围”，计算出”尼姑”的地址C，即可直接获取尼姑。 优点：散列结构的查找、插入、删除效率高。 缺点: 不支持排序、比用线性表存储需要更多的空间、基于数组的散列表扩展比较麻烦。 （笔者感慨：散列存储结构可以说是一件艺术品，在这里不得不佩服科学家们。网上有一种说法：Hash是一名科学家，由他提出了散列算法，所以命名为Hash算法。可是查无此人，知道的可以留言告诉我一下） 三、算法​ 后面章节会具体简介 总结本篇内容可以总结为下图 数据结构的应用： 这些内容可以说是古代劳动人民智慧的结晶，很多数据结构我们都可以直接拿来用。但是！这些计算机底层的东西，一定不能被动地记忆，要辩证地思考，上面的一切都不是真理，可能随着时间会慢慢被改进或者淘汰。]]></content>
      <categories>
        <category>计算机</category>
        <category>Java</category>
        <category>干了这杯源码</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合框架</tag>
        <tag>源码</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
