<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【干了这杯源码】集合框架 Collection接口介绍（一）]]></title>
    <url>%2F2018%2F10%2F08%2F%E3%80%90%E5%B9%B2%E4%BA%86%E8%BF%99%E6%9D%AF%E6%BA%90%E7%A0%81%E3%80%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-Collection%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Collection接口概述​ Collection是集合框架的根接口(root interface)，一个Collection代表了一组元素的集合，一部分Collection允许元素重复、有序排列，一部分则相反，在JDK中没有提供任何直接实现Collection的实现类，但是提供了很多特异性的子接口，例如Set、List和Queue，这些子接口将会极大程度地覆盖日常开发使用的情景。 所有实现Collection接口的实现类都包含了两个构造器: 1.无参构造器 2.参数为Collection的构造器(该构造器将会构造出与参数Collection元素相同的集合) 值得注意的是，此处并无方法强制去规定实现类要包含这两个构造器(因为接口不能定义构造器)，但是所有的Collection实现类都遵循了这项规定。 ​ 一些Collection的实现类对元素进行了限制。比如,有些Collection实现类禁止null元素，有些则限制了元素的类型。一旦企图去添加无资格(ineligible)的元素将会抛出非检查型异常(Unchecked Exception) ,企图去查询无资格(ineligible)的元素也有有可能会抛出异常，或者直接return false。 ​ 另外，集合是否线程安全取决于每个集合自身的同步策略。当这个集合缺乏一个强有力的线程保护时。 Collection全家桶 List接口​ 是一个有序、可重复、可为null的集合接口 List接口常用实现类为三个 ： 1、ArrayListList接口中最实用的实现类，底层由数组构成 2、LinkedListLinkedList的数据结构是双向链表。它也可以被当作堆栈、队列或双端队列进行操作。 3、Vector通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。 3.1、StackStack类表示后进先出（LIFO）的对象堆栈。 Set接口不允许元素重复，集合元素唯一(元素可以为null)，无序。 Set接口常用实现类为 1、HashSetHashSet使用哈希表（hash table）实现的，其中的元素是无序的 1.1、LinkedHashSetLinkedHashSet介于HashSet和TreeSet之间。它基于一个由链表实现的哈希表，保留了元素插入顺序。 2、TreeSetTreeSet使用树形结构（红黑树）实现的，TreeSet中的元素是可排序的。 3、EnumSetEnumSet是一个专为枚举类设计的集合类，EnumSet中所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式或隐式地指定。EnumSet的集合元素也是有序的，EnumSet以枚举值在Enum类的定义顺序来决定集合元素的顺序。 Queue接口queue接口用于模拟队列数据结构,采用”先进先出”的方式 Deque数据结构为双端队列 Queue接口常用实现类为1.PriorityQueuePriorityQueue为优先队列，它的逻辑结构是一课完全二叉树（堆），存储结构其实是一个数组，具有堆的特点，可以实现小顶堆和大顶堆 2.ArrayQueueArrayQueue为基于数组实现的队列 3.LinkedListLinkedList为基于链表实现的队列 总结以上是Collection接口常用子接口及其常用实现类的介绍，有一点值得注意的是，Map接口虽然被理论上归入集合框架，但是于Collection并无交集，独立出来。]]></content>
      <categories>
        <category>计算机</category>
        <category>Java</category>
        <category>干了这杯源码</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合框架</tag>
        <tag>源码</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【干了这杯源码】集合框架 数据结构（零）]]></title>
    <url>%2F2018%2F10%2F08%2F%E3%80%90%E5%B9%B2%E6%BA%90%E7%A0%81%E3%80%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%20%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E9%9B%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[概述​ 本专题将会给大家来带Java最实用的东西—集合框架，并将会直接从源码入手，直接干源码！由于集合框架的底层离不开数据结构，想搞清楚List、Set、Map等的底层实现，必须先从数据结构开始讲起。所以开山第一篇，将会给大家介绍计算机的数据结构。 ​ 数据结构可以说是计算机入门必修课程，同时也是特别烧脑的纯理论知识。所以本篇将会尽量避开让人看不懂的奇奇怪怪的东西，以生动形象的图文并茂带你窥探神秘的数据结构。 什么是数据结构？ 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。 –《百度百科》 科学家和人类应该不是一个物种，他们定义的名词读起来都比较拗口、而且十分不好理解。 什么是数据结构，举个通俗易懂的例子： 比如在现实世界里，你、我、其他所有人都属于数据元素，我们每个人之间都存在着错综复杂的关系。就好比：你是大名鼎鼎的太子、拥有至高无上的权利和无尽的财富，而我是个小小的皇上，我们之间就所形成的关系就是数据结构。 数据结构分为三个部分 可能有人会有疑问，数据结构和算法有什么关系呢？其实，数据结构和算法是相辅相成的，在计算机领域里面，谁也离不开谁。倘若失去了数据结构，算法会显得无比空洞；抛开算法，数据结构将会变成摆设！本篇将主要介绍逻辑结构和物理结构，至于算法会在后续章节，具体问题详细分析。 一、逻辑结构逻辑结构简单来说是指数据元素之间的前后件关系，主要包括4类。 1.集合结构数据结构之间除了“属于同集合” 的关系外，别无其他关系。 上图所有人（数据元素）同属于一个皇宫（集合） 2.线性结构数据结构之间的元素是一对一的关系。 上图为一对一的线性结构，例子：数组、链表、栈和队列 3.树形结构数据结构之间的元素存在一对多的相互关系 上图所示为一对多的树形结构，举例：二叉树、红黑树 4.图形结构数据结构中的元素存在多对多的相互关系。 如上图所示，虽关系略微复杂，却反映出图形结构多对多的关系。 ​ 二、物理结构指数据的逻辑结构在计算机存储空间的存放形式。 （提醒：该部分为本篇的重点，也是后面篇章讲解集合框架所依赖的东西。本篇将由浅入深、循序渐进，后面在具体讲到某 一个具体集合类时，会结合具体的方法来解读对应的储存结构） 通常来说数据的物理结构分为四类： 1.顺序存储结构把逻辑上相邻的结点存储在物理位置上相邻的存储单元中，结点之间的逻辑关系由存储单元的邻接关系来体现。 好比↑：国王和士兵们一起去菜市场排队买苹果，此时他们排成一对，紧紧的站在一起，就形成了一个顺序存储结构。 优点：查询元素效率高 因为顺序存储结构在逻辑和物理都是相邻的排序，所以找第几个士兵，直接就可以定位到目标。 缺点：插入和删除元素效率低(随机位置) 由于此结构的特性，每次插入和删除都要使整一个存储结构前移或者后移，相当影响性能。 举个例子↓，假设你是大名鼎鼎的太子，拥有至高无上的权利和地位，你路过菜市场，看到大家都在排队买苹果，你也跟风要买。你不仅要买还要插队，大家没办法只能默默的往后退一步，让出第一的位置给你，这过程体现了顺序存储结构插入的效率低下。 删除元素也同理↓，国王在队伍后面目睹了这一切，下令处死太子，太子就被拉出去枪毙了，大家又依次往前一步。 2.链式存储结构在计算机中用一组任意的存储单元存储线性表的数据元素，结点间的逻辑关系是由附加的指针字段表示。简单来讲，逻辑上相邻的数据元素，在物理结构上可以随意存放，不要求物理结构相邻，同时每个逻辑相连的元素手里都拿着一把指针指向下一个元素。 就比如↑：国王和太子们乘坐搭巴士，上了巴士之后不一定要找两个相邻的位置，有位置就可以坐。国王只需记住第一个太子的位置，每一个太子都只记着下一个太子的位置，就形成了一个链式储存结构。 优点：插入和删除元素效率高(随机位置) 如上图所示↓，如果此时皇后也上了巴士，且皇后要坐在国王的下一个位 置，那么只需要将国王的指针指向皇后，皇后的指针指向A太子，就插入成功！ 缺点：查找元素效率低由于链式存储结构的特性，如果你要找到D太子，你必须先找到C太子，要找到C太子必须先找到B太子，以此类推，你要先找到国王，再从国王指引的方向一个一个找过去。 3.索引存储结构索引存储结构是用结点的索引号来确定结点存储地址,其优点是检索速度快,缺点是增加了附加的索引表,会占用较多的存储空间。 索引存储结构由于其除了数据元素本身之外，还额外创建索引表，索引表的每个节点包含了索引键值和指针，如下图所示↓（以二叉树为索引表） 国王记性不好，记不住每一个人的地址，所以额外创建了一个索引表，方便快速定位。比如今晚想找尼姑一起研究数据结构，不用一个一个房间去敲门，只需要找到索引表的尼姑，就可以找到尼姑的具体地址。 优点：数据检索的速度快 缺点： 创建索引需要占用物理空间和消耗时间 对数据元素进行维护的同时，索引表也需要进行维护，影响性能 4.散列存储结构定义：实质上就是通过节点的关键字，再通过某一特定的计算，算出该关键字对应的物理地址。 散列（哈希）表：用散列法存储的线性结构被称为散列表或者哈希表，使用的函数f(k)被称为散列函数或者哈希函数，f(k)的值被称为散列地址或者哈希地址。通常情况下，散列表的存储空间是一个一维数组，而其哈希地址为数组的下标。 举个栗子：国王希望将皇宫内所有女性，按照某些指数，进行计算、分类如下图↓ 将每个节点元素通过散列函数f(k)计算出地址，并存放到相应的位置，如此就形成了哈希表。 比如查询”尼姑”数据是否存在时，只需要根据”尼姑”的”三围”，计算出”尼姑”的地址C，即可直接获取尼姑。 优点：散列结构的查找、插入、删除效率高。 缺点: 不支持排序、比用线性表存储需要更多的空间、基于数组的散列表扩展比较麻烦。 （笔者感慨：散列存储结构可以说是一件艺术品，在这里不得不佩服科学家们。网上有一种说法：Hash是一名科学家，由他提出了散列算法，所以命名为Hash算法。可是查无此人，知道的可以留言告诉我一下） 三、算法​ 后面章节会具体简介 总结本篇内容可以总结为下图 数据结构的应用： 这些内容可以说是古代劳动人民智慧的结晶，很多数据结构我们都可以直接拿来用。但是！这些计算机底层的东西，一定不能被动地记忆，要辩证地思考，上面的一切都不是真理，可能随着时间会慢慢被改进或者淘汰。]]></content>
      <categories>
        <category>计算机</category>
        <category>Java</category>
        <category>干了这杯源码</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合框架</tag>
        <tag>源码</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我个人博客的第一篇博客，哈哈哈...]]></title>
    <url>%2F2018%2F10%2F07%2F%E6%88%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%EF%BC%8C%E5%93%88%E5%93%88%E5%93%88%20-%20%E5%89%AF%E6%9C%AC%20(2)%2F</url>
    <content type="text"><![CDATA[大家好测试！]]></content>
  </entry>
  <entry>
    <title><![CDATA[我个人博客的第一篇博客，哈哈哈...]]></title>
    <url>%2F2018%2F10%2F07%2F%E6%88%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%EF%BC%8C%E5%93%88%E5%93%88%E5%93%88%20-%20%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[大家好测试！]]></content>
  </entry>
  <entry>
    <title><![CDATA[我个人博客的第一篇博客，哈哈哈...]]></title>
    <url>%2F2018%2F10%2F07%2F%E6%88%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%EF%BC%8C%E5%93%88%E5%93%88%E5%93%88%2F</url>
    <content type="text"><![CDATA[大家好测试！]]></content>
  </entry>
  <entry>
    <title><![CDATA[我个人博客的第一篇博客，哈哈哈...]]></title>
    <url>%2F2018%2F10%2F07%2F%E6%88%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%EF%BC%8C%E5%93%88%E5%93%88%E5%93%88%20-%20%E5%89%AF%E6%9C%AC%20(3)%2F</url>
    <content type="text"><![CDATA[大家好测试！]]></content>
  </entry>
</search>
